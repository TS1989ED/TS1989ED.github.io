<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Heart of a Lio]]></title>
    <url>%2F2018%2F10%2F17%2FLioMessi%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Videos/Gatorade%20-%20Heart%20of%20a%20Lio.mp4"},"danmaku":{"id":"LioMessi","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>Inspirational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM02-Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F10%2F05%2FJVMpro02%2F</url>
    <content type="text"><![CDATA[概述对C、C++开发人员来说，在内存管理领域，他们有着最高的权力，但同时肩负着每一个对象从开始到终结的维护责任。而对于Java程序员而言，由于JVM的自动内存管理机制，Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将为成为一项十分艰难的工作。 运行时数据区域Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区。下面详细阐述各数据区所存储的数据类型。 程序计数器(Program Counter Register) 作用：记录当前线程所执行到字节码的行号。字节码解释器工作的时就是通过改变这个计数器的值来选取下一条所需要执行的字节码指令。 意义：由于JVM的多线程是通过线程轮换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。所以为了实现并行，并保证各个线程指令安全顺利执行，每条线程都需要有一个独立的程序计数器。 记录内容： 如果线程正在执行一个Java方法，计数器记录的是正在执行的虚拟字节码指令的地址。 如果正在执行Native方法，计数器值为空(Undefined)。 可能出现的异常：此内存区域是唯一一个在Java虚拟机规范中没有任何内存溢出异常(OutOfMemoryError)的区域。 Java虚拟机栈(Java Virtual Machine Stacks) Java内存区常被分为堆内存（Heap）和栈内存（Stack），其中栈内存其实指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分 作用：虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个线帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点： Java虚拟机栈也是线程私有的，它的生命周期与线程相同。 每一个方法从调用直至执行完成的过程就对应着一个线帧在虚拟机栈中从入栈到出栈的过程。 存储内容： 局部变量表，包括编译期可知的各种基本数据类型、对象引用(reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或次对象相关位置)、指向一条字节码指令的returnAddress类型 值得注意的是：局部变量表所需的内存空间在编译期间完成分配。在方法运行的阶段是不会改变局部变量表的大小的 可能出现的异常： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果在动态扩展内存的时候无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈(Native Method Stack) 特点：与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法则为虚拟机所使用的Native方法服务 可能抛出的异常：与虚拟机栈一样，本地方法栈区域也乎抛出StackOverflowError和OutOfMemoryError异常。 Java堆(Java Heap) Java堆是垃圾收集器管理的主要区域（GC堆），可细分为：新生代，老年代，按空间可细分为：Eden空间，From Survivor空间，To Survivor空间 作用： Java Heap是被所有线程共享的一块区域，在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，让对象实例更好地分配内存。 垃圾回收机制(GC)：堆是垃圾收集器管理的主要区域，可以更好地回收内存。 存储内容： 存放对象实例，几乎所有的对象实例都在这里进行分配。堆可以处于物理上不连续的内存空间，只要逻辑上是连续的就可以。 值得注意的是：在JIT编译器等技术的发展下，所有对象都在堆上进行分配已变得不那么绝对。有些对象实例也可以分配在栈中。 可能出现的异常： 实现堆可以是固定大小的，也可以通过设置配置文件设置该为可扩展的。 如果堆上没有内存进行分配，并无法进行扩展时，将会抛出OutOfMemoryError异常。 方法区(Method Area) 作用：方法区和Java堆一样，是各个线程共享的内存区域。 意义：对运行时常量池、常量、静态变量等数据做出了规定。 存储内容：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 可能出现的异常：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池(Runtime Constant Pool) 作用用于存放编译期生成的各种字面量和符号的引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 特征运行时常量池对于Class文件常量池的另一个特征是具备动态性，在运行期间也可能将新的常量放入池中，例如String类的intern() 可能抛出的异常运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存(Direct Memory) 作用JDK1.4中新加入NIO类，引入一种基于通道与缓冲的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffeer对象作为这块内存的引用进行操作。（在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回复制数据） 可能抛出的异常服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常会忽略直接内存，使得内存区域总和大于物理内存限制(包括物理等和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。 HotSpot虚拟机对象对象创建 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 内存分配的两种方式： 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定 指针碰撞Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离 空闲列表Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding） HotSpot虚拟机的对象头包括两部分信息： Mark Word第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。 类型指针对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。 对象的访问定位 建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。 目前主流的访问方式有使用句柄和直接指针两种： 句柄访问 直接指针访问 对比优势： 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。Sun HotSpot虚拟机是使用第二种方式进行对象虚拟机访问的。 OutOfMemoryError异常 除了程序计数器，其他运行时区域都有可能抛出OutOfMemoryError异常 Java堆溢出 内存泄露查看泄露对象到GC Roots的引用链，定位泄露代码位置。 内存溢出如果不存在泄露，即内存中的对象确实都还必须活着，检查JVM堆参数（-Xmx与-Xms），调大参数，检查代码是否存在某些对象生命周期过长，持有状态过长的情况，减少程序运行期的内存消耗。 虚拟机栈、本地方法栈溢出HotSpot不区分虚拟机栈和本地方法栈，栈容量只能由-Xss参数设定。 StackOverFlow：线程申请的栈深度超过允许的最大深度 OutOfMemoryError： 虚拟机扩展时无法申请到足够的内存空间 StackOverFlow的情况：递归调用方法，定义大量的本地变量，增大此方法帧中本地变量表的长度。 OutOfMemoryError：多线程下的内存溢出，与栈空间是否足够大并不存在任何联系。为每个线程的栈分配的内存越大（参数-Xss），那么可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽，越容易内存溢出。在这种情况下，如果不能减少线程数目或者更换64位虚拟机时，减少最大堆和减少栈容量能够换区更多的线程。 方法区和运行时常量池溢出 运行时常量池String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用 方法区方法区用于存放Class的相关信息，如果运行时产生大量的类去填满方法区，就可能发生方法区的内存溢出。 例如主流框架Spring、Hibernate对大量的类进行增强时，利用CGLib字节码生成动态类；大量JSP或动态JSP(JSP第一次运行时需要编译为Java类）。 本机直接内存溢出Java虚拟机可以通过参数-XX:MaxDirectMemorySize设定本机直接内存可用大小，如果不指定，则默认与java堆内存大小相同。JDK中可以通过反射获取Unsafe类(Unsafe的getUnsafe()方法只有启动类加载器Bootstrap才能返回实例)直接操作本机直接内存。通过使用-XX:MaxDirectMemorySize=10M，限制最大可使用的本机直接内存大小为10MB。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Reading</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T-Bag]]></title>
    <url>%2F2018%2F10%2F04%2FT-Bag-Prelude%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/T-Bag.mp4"},"danmaku":{"id":"TBagPrelude","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM01-走近Java]]></title>
    <url>%2F2018%2F10%2F04%2FJVMpro01%2F</url>
    <content type="text"><![CDATA[第一章的内容大致翻阅了一下感觉还是挺多的，大致都是关于Java的特点、发展史、Java未来的走向以及阅读OpenJDK源码的指导。对于第一章的内容我也准备做一些总结，以备以后的扩充和温故。 Java的特性和优点 提升了开发效率 结构严谨，面向对象 摆脱硬件束缚，“一次编写，到处运行” 相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界问题(内存回收机制) 热点代码检测和运行时编译及优化，运行次数越多性能越好 完善的应用程序接口(第三方类库) Java的技术体系Sun公司所定义的Java技术体系包括以下几个组成部分： Jav程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式（面向对象的载体） Java API库（Java自带可调用的库） 来自商业机构和开源社区的第三方Java类库（封装好的库） JDK(Java Development Kit)：1+2+4，也就是支持Java开发的最小环境。JRE(Java Runtime Environment)：JavaSE(Java Standard Edition)的API+虚拟机。 Java技术体系模块图： 按照技术服务领域划分，Java技术体系可以分为4个平台： JavaCard：支持一些Java小程序运行在小内存设备上的平台，如智能卡 JavaME(Micro Edition)：支持Java运行在移动终端上的平台，对JavaAPI有所精简，并加入了针对移动端的支持 JavaSE(Standard Edition)：支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API。 JavaEE(Enterprise Edition)：支持使用多层架构的企业应用(如ERP、CRM应用)的Java平台，对JavaSE API做了大量的扩充并提供相关的部署支持 入门版(Card)👉阉割版(ME)👉标配(SE)👉Pro(EE) Java发展史 1991年，提出绿色项目（猜想可能是针对c/c++中的垃圾回收，内存处理之类的问题而提出的一个更友好的语言概念）; 创立oak（java语言的前身，为了解决家用电器的通信问题而诞生，没有理想市场，不久后将要失败）;设计出硬件原型；同时设计出注释器。 1992年，更名为java; Star-Seven Prototype(七星原型，度娘上查了好久没找到，有机会去翻墙再查吧。 猜想可能是当时那个版本的七大基本规范吧。。。先记下来); 1993年，TV Set-top Box ( 可能是在电视机顶盒 试用吧)；发布应用开发平台。。 1994年，LiveOak（可能是oak发展有一些起色的意思吧。英语不好真的很忧伤。）;发布Era浏览器；继而发布HotJava浏览器；设计出java编译器； 1995年，正式注册java,并相继获得Netscape,Oracle,Microsoft的支持，HotJava进一步发展。 1996年，java1.0发布。 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1997年，java1.1发布。 1997年9月，JavaDeveloperConnection社区成员超过十万 。 1998年2月，JDK1.1被下载超过2,000,000次 1998年，java1.2发布。 1998年12月8日，JAVA2企业平台J2EE发布。 1999年6月，SUN公司发布Java的三个版本：标准版、企业版和微型版（J2SE、J2EE、J2ME） 2000年，java1.3发布。 2002年，java1.4发布，自此Java的计算能力有了大幅提升。 2004年，java5.0发布，J2SE1.5发布，是Java语言的发展史上的又一里程碑事件。为了表示这个版本的重要性，J2SE1.5更名为J2SE5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字“2”：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。 2006年，java6.0发布，并半开源。 2010年，Oracle收购Sun公司，苹果不再支持java 2011年，java7.0发布。 2014年，java8.0发布。 Java虚拟机发展史 Sun Classic/Exact VM(初代)：世界上第一款商用Java虚拟机，Sun公司研发，主要特点：慢。 Sun HotSpot VM(新技术)：目前使用范围最广的虚拟机，是Sun从一家名为Longview Technologies公司收购来的。主要特点：热点探测技术。 Sun Mobile-Embedded VM/Meta-Circular VM(探索)：面对移动嵌入式市场的探索 BEA JRockit /IBM J9 VM(其它公司)：当时号称”世界上最快的Java虚拟机” Azul VM/BEA Liquid VM(特定硬件)：高性能Java的武器，特定硬件可以最大限度地发挥硬件的能力，提升Java程序的执行能力。 Apache Harmony/Google Android Dalvik VM(高速发展)：安卓虚拟机。是Android平台的核心组成部分之一。 Microsoft JVM(彩蛋)：2333 Java的未来 模块化：说起来也就是解除功能模块和功能模块之间的耦合，降低系统维护消耗。(书上也没仔细说，大家看着标题脑补一下也就知道是干嘛的) 混合语言：对系统来说是好事(因为不同语言有不同语言的特点 也就是擅长的地方)，但是对于Java程序员的要求也会因此而提高。 多核并行：顺应发展 丰富语法：更新JDK版本 64位虚拟机：现在64位虚拟机速度没有32位快，主要是Java EE对64位虚拟机的要求比较急迫。 自己编译JDK想要一探JDK内部的实现机制，最便捷的路径之一就是自己编译一套JDK，通过阅读和跟踪调试JDK源码去了解Java技术体系的原理，虽然门槛会高一点，但肯定会比阅读各种书籍、文章更加贴近本质。另外，JDK中很多底层方法都是本地化的，需要跟踪这些方法的运作或对JDK进行Hack的时候，都需要自己编译一套JDK。 OpenJDK源码结构图： 123456789101112131415161718192021222324252627282930313233343536373839├─agent Serviceability Agent的客户端实现 ├─make 用来build出HotSpot的各种配置文件 ├─src HotSpot VM的源代码 │ ├─cpu CPU相关代码（汇编器、模板解释器、ad文件、部分runtime函数在这里实现） │ ├─os 操作系相关代码 │ ├─os_cpu 操作系统+CPU的组合相关的代码 │ └─share 平台无关的共通代码 │ ├─tools 工具 │ │ ├─hsdis 反汇编插件 │ │ ├─IdealGraphVisualizer 将server编译器的中间代码可视化的工具 │ │ ├─launcher 启动程序“Java” │ │ ├─LogCompilation 将-XX:+LogCompilation输出的日志（hotspot.log）整理成更容易阅读的格式的工具 │ │ └─ProjectCreator 生成Visual Studio的project文件的工具 │ └─vm HotSpot VM的核心代码 │ ├─adlc 平台描述文件（上面的cpu或os_cpu里的*.ad文件）的编译器 │ ├─asm 汇编器接口 │ ├─c1 client编译器（又称“C1”） │ ├─ci 动态编译器的公共服务/从动态编译器到VM的接口 │ ├─classfile 类文件的处理（包括类加载和系统符号表等） │ ├─code 动态生成的代码的管理 │ ├─compiler 从VM调用动态编译器的接口 │ ├─gc_implementation GC的实现 │ │ ├─concurrentMarkSweep Concurrent Mark Sweep GC的实现 │ │ ├─g1 Garbage-First GC的实现（不使用老的分代式GC框架） │ │ ├─parallelScavenge ParallelScavenge GC的实现（server VM默认，不使用老的分代式GC框架） │ │ ├─parNew ParNew GC的实现 │ │ └─shared GC的共通实现 │ ├─gc_interface GC的接口 │ ├─interpreter 解释器，包括“模板解释器”（官方版在用）和“C++解释器”（官方版不在用） │ ├─libadt 一些抽象数据结构 │ ├─memory 内存管理相关（老的分代式GC框架也在这里） │ ├─oops HotSpot VM的对象系统的实现 │ ├─opto server编译器（又称“C2”或“Opto”） │ ├─prims HotSpot VM的对外接口，包括部分标准库的native部分和JVMTI实现 │ ├─runtime 运行时支持库（包括线程管理、编译器调度、锁、反射等） │ ├─services 主要是用来支持JMX之类的管理功能的接口 │ ├─shark 基于LLVM的JIT编译器（官方版里没有使用） │ └─utilities 一些基本的工具类 └─test 单元测试]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Reading</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何编写Alfred Workflow]]></title>
    <url>%2F2018%2F09%2F21%2FAlfredKnowledgeBase%2F</url>
    <content type="text"><![CDATA[语言基础Alfred官方并没有给出详细的Alfred Workflow撰写教程，原因是写一个Workflow的实际门槛是很低的。他们大部分是使用一门了解的语言来书写的。在Alfred也罗列了这些语言： 包括： bash, zsh, PHP, Ruby, Python, Perl, AppleScript, JavaScript 开发者只需要会使用上面任意的语言，就可以开始编写自己的Alfred Workflow了。 如何使用Alfred？Alfred有个很好的地方，就是能在Alfred中看到你所使用的Alfred的具体实现，workflow也都是开源的。大部分workflow都可以直接在Alfred的workflows选项卡下看到，部分workflow可能需要调用一些脚本文件，你也可以进入对应的workflow文件夹下打开具体的脚本文件（可以通过workflows👉Show in Finder打开对应的workflow文件夹） Alfred workflow有几个关键组成部分，包括Triggers、Inputs、Actions、Outputs。 Triggers用于设置快捷键，并不是必备的，因为Option+Space快捷键就可以快捷打开Alfred输入框 Inputs定义了在Alfred输入框中输入对应的keyword调用相关的操作 Action就是keyword调用的操作 Outputs一般用于显示操作的结果，提示操作成功与否，以Post Notification较为常见，通过Mac的notification center提示。 🤨Alfred使用手册🤨👉Alfred2.5.1使用全攻略👉Alfred：基础功能及设置👉编写 Alfred 使用的 Workflow]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
        <tag>Workflow</tag>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred的OSS图床Workflow(python)]]></title>
    <url>%2F2018%2F09%2F20%2FAlfredWorkflowOSS%2F</url>
    <content type="text"><![CDATA[前言什么是Alfred？Alfred依靠它强大的工作流机制，可以极大地提高Mac系统的工作效率。 作为 Mac 上最强大的效率工具，Alfred 在 Spotlight（MacOS X 自带的搜索和快速启动引擎）的基础上优化了快速启动与搜索的功能，还引入了 Workflows 等强大的扩展功能，使之成为了一个拥有无限自动化潜力的「工具平台」软件，可以用它来实现近乎一切有关自动的想法。 为什么要使用这个Workflow？因为在编写个人博客，每次插入图片的时候都需要将图片上传到OSS图床，具体需要以下步骤： 截图 保存图片到桌面 打开浏览器 登陆阿里云 打开OSS控制台 上传图片 等待并获取url 回到markdown编辑器粘贴到![]()中 而现在使用这款插件只需要三步： 截图 Toggle Alfred 并键入：OSS 回到markdown编辑器粘贴 好吧，其实主要还是因为穷QAQ，因为不需要折腾的iPic需要订阅，每年¥68。 安装及配置环境 一台MacOS的电脑 Alfred 阿里云OSS python3环境 python3依赖oss2和pyobjc包 👉python3安装教程 安装依赖打开命令行输入：1pip install oss2 1pip install pyobjc 脚本需要修改的参数修改位置：右键OSS - 选择Open in Finder - 修改其中的clipboard_data.py文件 修改下面这三行的内容： 123access_key_id = &apos;&lt;yourAccessKeyId&gt;&apos;access_key_secret = &apos;&lt;yourAccessKeySecret&gt;&apos;bucket_name = &apos;&lt;yourBucketName&gt;&apos; 1bucket = oss2.Bucket(auth, &apos;http://oss-cn-hangzhou.aliyuncs.com&apos;, bucket_name) 👉如何获取AccessKey ID和Secret 如何使用复制一张图片，调用alfred，输入oss命令稍等一小会儿，会显示url和md两种返回格式，点击url或者md便可以获得对应地址在剪切板中，粘贴，所见即所得 👉GIthub地址 最后，感谢 @CQhui 写的AlfredWorkflow！]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
        <tag>tech</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识遗传算法]]></title>
    <url>%2F2018%2F09%2F18%2FGeneticAlgorithm01%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Videos/AI%20learns%20to%20play%20Google%20Chrome%20Dinosaur%20Game%20--%20Can%20you%20beat%20it.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() Github源码链接 什么是遗传算法？遗传算法的由来 Species to survive, is not the most strong, is not the most intelligent， but those who make a rapid response to change. 物尽天择，适者生存。 查尔斯达尔文在一百多年前提出的“生物进化论”，他证明生物的起源是在遗传、变异、生存斗争和自然选择中，从简单到复杂、从低等到高等不断地发展变化而来的。达尔文的进化论给美国的科学家霍兰德留下了深刻的印象，他从计算机角度思考了这个问题，也就是遗传算法的由来。遗传算法也便继承了“进化论”的思想，将需要解决的问题模拟成一个生物进化的过程，通过复制、交叉、突变等操作产生下一代的解，并逐步淘汰适应度(Fitness)低的解，经过N代自然选择后，会进化出适应度函数值很高的个体。 定义：&emsp;&emsp;遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。 相关术语 table th:nth-of-type(1){ width: 25%; } table th:nth-of-type(2){ width: 75%; } 相关术语 解释 基因型(genotype) 性状染色体的内部表现 表现型(phenotype) 染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现 进化(evolution) 种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的 适应度(fitness) 度量某个物种对于生存环境的适应程度 选择(selection) 以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程 复制(reproduction) 细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。 交叉(crossover) 两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交 变异(mutation) 复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状 编码(coding) DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射 解码(decoding) 基因型到表现型的映射 个体（individual） 指染色体带有特征的实体 种群（population） 个体的集合，该集合内个体数称为种群的大小 遗传算法的应用遗传算法的有趣应用很多，诸如寻路问题，8数码问题，囚犯困境，动作控制，找圆心问题（在一个不规则的多边形中，寻找一个包含在该多边形内的最大圆圈的圆心），TSP问题，生产调度，模式识别，神经网络，自适应控制等。 一个简单的例子求解函数 f(x) = x + 10*sin(5*x) + 7*cos(4*x) 在区间[0,9]的最大值 那么如何通过遗传算法找到这个函数的最大值呢？ 事实上，不管一个函数的形状多么奇怪，遗传算法都能在很短的时间内找到它在一个区间内的(近似)最大值。 👉具体分析 遗传算法思想GA的组成： 编码(产生初始种群)👉创造染色体 个体👉种群 适应度函数 遗传算子(选择、交叉、变异) 运行参数 种群大小 染色体长度 最大迭代次数 交叉概率 变异概率 是否选择精英操作 GA算法特点遗传算法的优点 群体搜索，易于并行化处理； 不是盲目穷举，而是启发式搜索； 适应度函数不受连续、可微等条件的约束，适用范围很广。 容易实现。一旦有了一个遗传算法的程序，如果想解决一个新的问题，只需针对新的问题重新进行基因编码就行；如果编码方法也相同，那只需要改变一下适应度函数就可以了。 遗传算法的缺点 全局搜索能力不强,很容易陷入局部最优解跳不出来；(可结合SA进行改进,因为SA在理率上是100%得到全局最优的,但搜索代价高) 将遗传算法用于解决各种实际问题后，人们发现遣传算法也会由于各种原因过早向目标函数的局部最优解收敛，从而很难找到全局最优解。其中有些是由于目标函数的特性造成的，例如函数具有欺骗性，不满足构造模块假说等等；另外一些则是由于算法设计不当。为此，不断有人对遗传算法提出各种各样的改进方案。例如：针对原先的定长二进制编码方案；提出了动态编码、实数编码等改进方案；针对按比例的选择机制，提出了竞争选择、按续挑选等改进方案；针对原先的一点交算子，提出了两点交、多点交、均匀交等算子；针对原先遗传算法各控制参数在进化过程中不变的情况，提出了退化遗传算法、自适应遗传算法等。另外，针对不同问题还出现了分布式遗传算法、并行遗传算法等等。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云产品]]></title>
    <url>%2F2018%2F09%2F16%2FAbout-AliCloud%2F</url>
    <content type="text"><![CDATA[产品及功能ESC(Elastic Compute Service)以虚拟机的方式将一台物理机分成多台云服务器，提供可伸缩的计算服务。 衍生产品： 阿里云从云服务器ESC衍生出来很多云服务器系列，例如适用于初级用户的轻量应用服务器，还有 为了迎合各种高性能场景的云服务器，诸如GPU云服务器、FPGA云服务器等，总之都是云服务器，是企业上云的基本款。 关于轻量应用服务器： 精简了一些 ECS 的功能，比如说安骑士。把安全组的操作也做了适当减法更适合用户操作。 轻量应用服务器有轻量两个字，意味着其无法持续进行高负载运行（即 CPU 长时间高负载占用），如果我们要利用 轻量应用服务器 来进行持续的渲染、转码、机器学习等持续高负载操作那么就不可以了，也不支持 Nvme 这样的超高性能的 SSD，这对于读写敏感的操作就不好了。 阿里云的“云翼计划”的学生服务器就是轻量应用服务器。 RDS(Relational Database Service)通过云服务的方式让关系型数据库管理、操作和扩展变得更加简单。 OSS(Open Store Service)对任意大小数据对象提供高可用、高可靠的海量存储服务。 相关文章： 阿里云对象存储OSS SLB(Server Load Balance)基于LVS和Tengine实现的4层和7层负载均衡，有动态扩容。 OCS(Open Cache Service)基于内部Tair，增加一层Proxy，支持海量小数据的高速访问。 OTS(Open Table Service)海量(结构化)数据存储和实时查询服务 CDN(Content Delevery Network)通过覆盖全网的缓存服务以及负载均衡等技术将用户请求定向到最合适的区域，提高用户服务的响应速度及网站服务能力。 OAS(Open Archive Service)离线归档，冷数据备份，类似Amazon Glacier ODPS(Open Data Processing Service)海量数据处理和分析平台。 SLS(Simple Log Service)解决异构、分布式系统中日志实时收集、存储与查询的基础服务]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[血小板まとめ]]></title>
    <url>%2F2018%2F09%2F14%2FHataraku-Cute%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/%E3%80%8C%E3%81%8A%E7%96%B2%E3%82%8C%E6%A7%98%E3%81%A6%E3%82%99%E3%81%99%EF%BC%81%E3%80%8D%E8%A1%80%E5%B0%8F%E6%9D%BF%E3%81%AE%E7%AC%91%E9%A1%94%E3%81%8B%E3%82%99%E5%8F%AF%E6%84%9B%E3%81%99%E3%81%8D%E3%82%99%E3%82%8B%E3%80%90%E3%81%AF%E3%81%9F%E3%82%89%E3%81%8F%E7%B4%B0%E8%83%9E%E3%80%91Hataraku%20Saibou%20Cute%20Moments.mp4"},"danmaku":{"id":"Platelet","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Anime</tag>
        <tag>Cute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云对象存储OSS]]></title>
    <url>%2F2018%2F09%2F14%2FAliCloudOSS%2F</url>
    <content type="text"><![CDATA[OSS阿里云对象存储服务（Object Storage Service，简称 OSS），提供海量、安全、低成本、高可靠的云存储服务。其性质相当于阿里云提供的网盘服务，支持最基本的上传和下载，支持外链。OSS的存储空间以外网流出流量都是要收费的 CDN（CDN加速）全称：Content Delivery Network，内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络，替代传统以WEB Server为中心的数据传输模式。相当于访问就近的服务器点就个人博客而言，不需要CDN加速 存储量存储量指占用的存储空间容量 流量流量指您使用的网络带宽流量累计值，包括外网流出流量、内网流出流量、外网流入流量、内网流入流量、CDN回源流出流量、跨区域复制流量： 外网流出流量(收费): 通过互联网从 OSS 下载数据到本地端所产生的下行流量 内网流出流量(免费): 通过阿里云内网从 OSS 下载数据到 ECS 服务器所产生的下行流量 外网流入流量(免费) : 通过互联网从本地端上传数据到 OSS 所产生的上行流量 内网流入流量(免费) : 通过阿里云内网从 ECS 服务器上传数据到 OSS 所产生的上行流量 CDN回源流出流量(收费) : 通过 CDN 服务层下载 OSS 的数据所产生的回源下行流量 跨区域复制流量(收费) : 使用跨区域复制功能将源 Bucket 的数据同步复制到目标 Bucket 时所产生的流出流量 请求次数调用 OSS OPEN API 的请求次数。比如: 你的一篇博客中有6张图片(都是使用OSS存储做外链),那么当你打开这篇博客时就产生了6次请求。另外: OSS 控制台操作也是通过 OSS OPEN API 调用实现的，因此使用 OSS 控制台也会产生请求次数。 收费模式： 按量付费： 存储费用：存储单价 x 存储量 流量费用：外网流出流量忙时单价 x 流量 请求费用：Put请求 + Get请求汇总的费用 包年包月： 存储费用：存储包平均每月的费用 流量费用：外网流出流量包平均每月的费用 请求费用：Put请求 + Get请求汇总的费用 OSS+CDN组合： 存储费用：存储包平均每月的费用 流量费用：CDN公网流量费用 + CDN回源流量费用 请求费用：CDN回源请求费用 总结：个人博客建议按流量计费]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nike-Dream Crazy]]></title>
    <url>%2F2018%2F09%2F14%2FNike-Dream-Crazy%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Nike%20-%20Dream%20Crazy.mp4"},"danmaku":{"id":"NikeDreamCrazy","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>广告</tag>
        <tag>Share</tag>
        <tag>Inspirational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶]]></title>
    <url>%2F2018%2F09%2F04%2FAdvancedOperationInHexo%2F</url>
    <content type="text"><![CDATA[目录结构12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 为什么在custom.styl修改CSS文件?👉Stylus让CSS也能编程 修改文章页宽打开\themes\next\source\css\ _variables\base.styl文件，找到以下字段并修改为合适的宽度: 1content-desktop-large = 1000px 修改小型代码块颜色修改\themes\next\source\css\ _variables\base.styl文件，修改代码加入自定义颜色： 123456789$black-deep = #222$red = #ff2a2a$blue-bright = #87daff$blue = #0684bd$blue-deep = #262a30$orange = #fc6423// 下面是我自定义的颜色$my-code-foreground = #dd0055 // 用``围出的代码块字体颜色$my-code-background = #eee // 用``围出的代码块背景颜色 修改$code-background和$code-foreground的值 123456// Code &amp; Code Blocks // 用``围出的代码块 // -------------------------------------------------- $code-font-family = $font-family-monospace $code-font-size = 15px $code-background = $my-code-background $code-foreground = $my-code-foreground $code-border-radius = 4px 添加文章结束标记同样在themes/next/layout/_macro/post.swig 中，在 wechat-subscriber.swig之前添加如下代码： 1&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt; 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果修改themes\next\source\css\_common\components\sidebar\sidebar-author.styl： 1234567891011121314151617181920212223242526272829.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 修改链接文字样式打开themes\next\source\css\_common\components\post\post.styl添加以下代码，给链接添加颜色： 12345678.post-body p a&#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #ff106c; text-decoration: underline; &#125;&#125; 为next主题的主页文章添加阴影效果打开themes/next/source/css/_custom/custom.styl文件添加： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 为next主题添加nest背景特效背景几何线条是采用的nest效果，一个基于html5 canvas绘制的网页背景效果，非常赞！来自github的开源项目canvas-nest 特性 不依赖任何框架或者内库，比如不依赖 非常小，只有1.66kb 非常容易实现，配置简单，即使不是web的开发者，也能简单搞定 配置选项 color: 线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B)，注意用,分割 opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 不足：CPU占用过高 修改_layout.swig打开next/layout/_layout.swig在&lt;/body&gt;之前添加如下代码 可参考官方文档：Canvas-Nest 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 修改主题配置文件打开/next/_config.yml，添加如下代码 1234567# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 运行hexo clean 和 hero g -d 之后就可以在网页上看到效果了。 隐藏网页底部powered by hexo/强力驱动打开hexo/themes/next/layout/_partials/footer.swig 找到下面这段代码，用第一行和最后一行注释掉即可 123456789101112131415&lt;!--&lt;div class="powered-by"&gt;&#123;# #&#125;&#123;&#123; __('footer.powered', '') &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; &lt;/div&gt;--&gt; 侧栏加入已运行时间themes/next/layout/_custom中添加sidebar.swig文件: 1234567891011121314151617181920212223242526&lt;div id="days"&gt;&lt;/div&gt; &lt;script&gt; function show_date_time()&#123; window.setTimeout("show_date_time()", 1000); BirthDay=new Date("01/10/2017 12:34:56"); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"; &#125;function setzero(i)&#123; if (i&lt;10) &#123;i="0" + i&#125;; return i;&#125;show_date_time();&lt;/script&gt; 在themes/next/layout/_macro/sidebar.swig中的&lt;/section&gt;之前添加: 1&#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; 设置时间样式： 1234567// 自定义的侧栏时间样式#days &#123; display: block; color: #fffa74; font-size: 14px; margin-top: 15px;&#125; 更改tagcloud为彩色themes/next/layout/page.swig找到tagcloud并替换: 1&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125; 设置动态titlethemes/next/source/js/src下创建dytitle.js： 12345678910111213141516var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="shortcut icon"]').attr('href', "/TEP.png"); document.title = 'w(ﾟДﾟ)w 出BUG啦！！！！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="shortcut icon"]').attr('href', "/favicon.png"); document.title = '♪(^∇^*)又好了。。。 ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125;&#125;); 修改themes/next/layout/layout.swing,在 &lt;/body&gt; 之前添加: 1&lt;script type="text/javascript" src="/js/src/dytitle.js"&gt;&lt;/script&gt; 修改文章底部带#的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 文字样式先在themes/next/source/css/_custom/custom.styl中添加以下样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// 下载样式a#download &#123;display: inline-block;padding: 0 10px;color: #000;background: transparent;border: 2px solid #000;border-radius: 2px;transition: all .5s ease;font-weight: bold;&amp;:hover &#123;background: #000;color: #fff;&#125;&#125;/ /颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #f0ad4e;&#125;// 颜色块-绿span#inline-green &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #9954bb;&#125;// 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#125; 用法如下： 12&lt;span id=&quot;inline-blue&quot;&gt;站点配置文件&lt;/span&gt;， &lt;span id=&quot;inline-purple&quot;&gt;主题配置文件&lt;/span&gt; 站点配置文件，主题配置文件 12&lt;p id="div-border-left-red"&gt;左边红色&lt;/p&gt;&lt;p id="div-border-top-blue"&gt;上边蓝色&lt;/p&gt; 左边红色上边蓝色 在文档中增加图标采用的是Font Awesome的图标。 给文档加密打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在开头的四个meta之后插入以下代码：1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在MD文章头文件中加入 password: password 侧边栏推荐阅读打开主题配置文件修改成这样就行了（links里面写你想要推荐的链接）：1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 新增评论系统去除评论系统下方的powered by valine打开/next/layout/_third-party/comments/valine.swig文件，123456789101112131415161718new Valine(&#123; el: '#comments' , verify: &#123;&#123; theme.valine.verify &#125;&#125;, notify: &#123;&#123; theme.valine.notify &#125;&#125;, appId: '&#123;&#123; theme.valine.appid &#125;&#125;', appKey: '&#123;&#123; theme.valine.appkey &#125;&#125;', placeholder: '&#123;&#123; theme.valine.placeholder &#125;&#125;', avatar:'&#123;&#123; theme.valine.avatar &#125;&#125;', guest_info:guest, pageSize:'&#123;&#123; theme.valine.pageSize &#125;&#125;' || 10,&#125;);//新增以下代码即可，可以移除.info下所有子节点。var infoEle = document.querySelector('#comments .info');if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123; infoEle.childNodes.forEach(function(item) &#123; item.parentNode.removeChild(item); &#125;);&#125;]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[裂纹识别初探]]></title>
    <url>%2F2017%2F10%2F23%2FCrackIdentify%2F</url>
    <content type="text"><![CDATA[裂纹识别的基本步骤 基于概率模型的裂纹识别算法总结 思路：仍然基于传统的模式识别方法，通过计算已知模板与图像的相关性，但是裂纹的形状与走向具有很大的随机性，引入概率论可以更好地建立模板。将概率论引入到理想裂纹模型的建立中，并将所建立的概率模型映射为理想模板。通过计算理想模板与图像像素点对应区域的Bhattacharyya系数来评定像素为裂纹的可能性。进而从X光图像中自动地提取裂纹轮廓。 关于Bhattacharyya系数（相似系数）：可以衡量两个向量间的相似程度。 裂纹中心点概率模型：通过观察裂纹图像发现裂纹中心点灰度低，两侧稍高，裂纹整体灰度地域背景灰度。根据裂纹图像的特点，将裂纹的中心曲线看作是裂纹中心点沿着曲线运动的轨迹。假设理想裂纹的中心点分布概率服从高斯分布，则任意剖面都满足高斯分布。模型窗口中心点是裂纹中心点的概率最大。 理想裂纹模板：基于裂纹灰度分布特点，将理想模型映射成理想模板。 裂纹识别算法： 图像预处理：（处理背景噪声） 斯通滤波：图像中的噪声绝大部分都位于图像频谱中的高频部分，通过高斯低通滤波器，滤除原始图像中的高频部分，避免理想模板与噪声发生误匹配。 阈值分割：采用改进的OSTU方法对图像进行灰度阈值分割，计算出合适的灰度阈值T 灰度拉伸：根据灰度阈值T，将灰度值高于T的像素灰度置为255.确定合适的门限值M，讲地域该门限的像素灰度置为0，根据先验经验，裂纹中心灰度的范围浮动低于10个灰度级左右。（二值化） 灰度拉伸的作用：增强原始图像的对比度，增加裂纹与模板的相似程度，从而增加了识别的准确性 算法流程： 根据式(2)将理想概率模型映射为理想模板矩阵 B。 统计模板矩阵 B 中元素对应的灰度概率分布，建立模 板的概率矩阵 B1，B1 中的元素为 B 中该元素灰度值在模板 中出现的概率。 对预处理后的原始图像进行逐像素循环，计算以当前 点为中心，模板矩阵区域大小内像素灰度分布概率为 i p ，再 根据 i p 与 B1 计算该区域对应的 Bhattacharyya 系数，并将其 作为当前点的替代值，遍历原始图像后生成相似系数矩阵。 将相似系数矩阵映射为灰度图像矩阵，并将其二值化。 对二值图像进行形态学操作，从而在二值图像中得到 裂纹的完整轮廓。将裂纹的轮廓和所在区域在原始图像中标 记出来，从而达到识别裂纹的目的。 形态学操作——消除二值化后的的噪声点 形态学操作流程：图像取反—关运算—膨胀—填充—腐蚀 形态学操作中膨胀和腐蚀的尺度必须一致，否则得到的轮廓尺寸便被人为地引入了方法误差。 经过形态学操作后得到了完整的裂纹轮廓，通过边缘检测算法，将该二值图像中的裂纹轮廓重绘于其对应的原始图像上，并在原始图像上标定出裂纹区域信息，从而完成了对裂纹的识别。 基于图像处理的微波处理材裂纹总结 思路：利用matlab软件中的图像处理模块，通过编程对微波处理木材表面裂纹的彩色扫描图像类型转换、图像增强、图像分割及图像形态学处理，提取图像中存在的裂纹，并最终对裂纹信息进行统计。 图像类型转换： Matlab图像处理模块提供了许多图像类型转换函数，通过这些函数可以实现RGB图像、灰度图像、索引图像及二值图像之间的相互变换。 由于图像后期处理都是在灰度图像基础上进行的，所以需要先将彩色扫描图像转换为灰度图像。在Matlab软件中，可通过调用rgb2gray函数实现彩色图像至灰度图像的转换。 图像增强： 在获取图像的过程中，各种干扰因素的存在会导致源图像中存在噪声，从而影响图像的质量。因此必须先对图像进行增强处理，图像增强可以将图像中感兴趣的特征有选择地突出，并衰减不需要的特征，以便后期对图像特征进行识别分析。 增强对比度：使源图像中各部分的反差增强。本文进行对比度增强处理的目的是使源图像中裂纹区域与其他部分的区别更为明显，主要通过imadjust函数实现。 锐化处理：经过以上的平滑滤波器对图像进行处理后，图像会有一定程度的模糊，进行锐化处理以突出图像的边缘信息，加强图像的轮廓特征，以便于人眼观察和机器识别。 二值图降噪处理：通过调用bwareaopen函数去除尺寸较小的噪声，经过降噪处理后，图像中有部分尺寸较大的噪声仍未去除，如果加大去噪过程中去除对象的尺度，会同时将部分较小的裂纹去除，因此不能采用该方法。而通过roifill函数，采用区域填充的方法可以达到去除大尺寸噪声的目的。 断裂纹闭合：采用形态学处理中的闭运算操作，通过创建一个平面的线性结构元素使裂纹的断裂区域闭合。 裂纹信息统计：采用matlab软件中形态学处理的操作，获得裂纹数量、裂纹长度、宽度及面积等信息，并由此计算机出图像中裂纹区域所占图像面积的比例。首先调用bwlabel函数对裂纹进行编号，可以统计图像中的裂纹数量。其次，利用regionprops函数可以计算出每条裂纹对应的长度、宽度和面积。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令对应的单词]]></title>
    <url>%2F2017%2F01%2F21%2FLinuxAbbreviation%2F</url>
    <content type="text"><![CDATA[特殊命名MySQL = My是最初作者女儿的名字，SQL = Structured Query LanguagePython 得名于电视剧Monty Python&rsquo;s Flying Circusawk = “Aho Weiberger and Kernighan” 三个作者的姓的第一个字母biff = 作者Heidi Stettner在U.C.Berkely养的一条狗,喜欢对邮递员汪汪叫。 目录名：/etc：ETCetera/bin：BINaries/dev：DEVices/lib：LIBraries/mnt：MouNT/proc：PROCesses/tmp：TeMPorary/var：VARiable/srv：SeRVices/opt：OPTion/sbin：Super BINaries（又作Superuser BINaries）/sys：SYStem/usr：Unix Shared Resources 文件管理（包括文件输出管理）：ls – LiStcd – Change Directorypwd – Print Working Directorycp – CoPymv – MoVerm – ReMovepushd – PUSH to Directorypopd – POP from Directorymkdir – MaKe DIRectoryrmdir – ReMove DIRectorycat – CATenatesed – Stream EDitordiff – DIFFerencewc – Word Countchmod – CHange MODechown – CHange OWNerchgrp – CHange GRouPawk – Aho Weinberger and Kernighangawk – Gnu Aho Weinberger and Kernighangrep – General Regular Expression Println – LiNktar – TARball 硬件管理：df – Disk Freedu – Disk Usagedd – Data Descriptionparted – PARTition EDitorlspci – LiSt Peripheral Component Interconnectlscpu – LiSt Central Process Unitlsusb – LiSt Universal Serial Bus 软件及软件包管理：man – MANualapt – Advanced Packaging Tooldpkg – Debian PacKaGeyum – Yellow dog Updater, Modifiedrpm – RPM Package Manager 系统管理：depmod – DEPend MODulelsmod – LiSt MODulemodprobe – MODule PROBEmodinfo – MODule INFOrmationinsmod – INSert MODulermmod – ReMove MODuleps – Processes Statussu – Substitute Userbash – Bourne Again SHellinit – INITializationssh – Secure SHellwine – Wine Is Not an Emulatorexec – EXECutefstab – FileSystem TABlepasswd – PASSWorDtty – TeleTYpesudo – SuperUser DOgrub – GRand Unified Bootloadertzselect – Time Zone SELECTsync – SYNChronize 编辑器：ed – EDitornano – Nano’s ANOther editoremacs – Editor MACroSvi – VIsualvim – Vi Improved 写程序时会用到的：cc – C Compilergcc – Gnu Compiler Collectiongcc – Gnu C Compilerg++ – Gnu c++ compilergcj – Gnu Compiler for Javayacc – Yet Another Compiler Compilerguile – Gnu Ubiquitous Intelligent Language for Extensionsgas – Gnu Assemblerphp – PHP：Hypertext Preprocessorld – Link eDitorgdb – Gnu DeBugtcl – Tool Command Line 图形界面：gnome – GNu Object Model Environmentgdm – Gnome Display Managergtk – Graphic user interface ToolKitqt – Toolkitkde – K Desktop Environmentlxde – Lightweight X11 Desktop Environmentxfce – XForms Common Environment 各种参数-a | –all ; –archive ; –append-b | –blocksize ; –batch-c | –commands ; –create-d | –debuge ; –delete ; –directory-e | –execute ; –edit ; –exclude-f | –force ; –file ; –configuration file-h | –help ; –human readable ; –headers-i | –interactive ; –include-k | –keep ; –kill-l | –long listing format ; –list ; –load-m | –message ; –manual ; –create home-n | –number ; –no-o | –output ; –options-p | –port ; –protocol ; –passwd-q | –quiet-r | –reverse ; –recursive-s | –silent ; –size ; –subject-t | –tag ; –type-u | –user-v | –verbose ; –version-w | –width ; –warning-x | –exclude-y | –yes-z | –zip 许可证：gnu gpl : Gnu General Public Licensegnu lgpl : Gnu General Lesser Public Licensegfdl : Gnu Free Documentation Licenseagpl : Affero General Public Licenseapsl : Apple Public Source Licensebsd : Berkeley Software Distribution license]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《鸟哥的私房菜》思维导图]]></title>
    <url>%2F2017%2F01%2F17%2FLinuxXmind%2F</url>
    <content type="text"><![CDATA[Linux学习计划 Linux文件、目录与磁盘格式 Shell与Shell Script]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
