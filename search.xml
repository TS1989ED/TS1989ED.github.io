<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[New Airpods]]></title>
    <url>%2F2019%2F06%2F28%2FAirpodsbounce%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Bounce.mp4"},"danmaku":{"id":"Bounce","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Ads</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>SomethingCool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反思和抉择]]></title>
    <url>%2F2019%2F06%2F23%2Fthink-out-loud%2F</url>
    <content type="text"><![CDATA[四年时光一晃而过，剩下个茫然无措的我 一直以来我都是信奉及时行乐的人，沉醉于当下的快乐让我在短时间里忘掉了所有需要我去直面的问题和困境。其实人都是很短视的动物，延迟满足感是很难的。过去的一年我所有的选择现在看来基本都是错误的，在决定了考研之后去参加了实习，在即将参加实习工作的时候又想要考研。多变让我没有办法在有限的时间致力于同一件事，总是会冒出一些奇怪的想法，然后做出乱七八糟的决定。这些小小的决定就一点点改变了我人生的走向。现在工作的同学都参与了工作积极转正，考研的同学都考上了自己期望中的学校准备深造。我便又一次陷入了迷茫，又开始质疑自己的决定。昨天看到了知乎对于20岁年轻人的建议，唯一的感悟就是，自己早一点看到这些就好了。但我看过的鸡汤以及人生建议还少吗？大道至简，知易行难，也便造就了不同人不同的人生。 那即将步入25岁的我们，到底应该做些什么呢？ 从不后悔自己走过的弯路，它是我自己的选择，也是我生命的一部分。 一个完全规律生活，事事精确控制的人，和一个不珍惜时间，生活彻底失控的人，在本质上都是一样的。辜负了生命赐予我们的无数精彩可能。经历本身也是一种财富。有些事现在不做，以后就真的再也没有机会了。在自己的青春了我做出了自己的选择，也必然要承受其中的代价。有得必有失，我只是想尽力留住那些我认为珍贵的东西，只是想要多留下一些珍贵的记忆。大不了，也就是年轻不成熟时“走过的弯路”罢了。]]></content>
      <tags>
        <tag>Reflect on myself</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MFCC探索]]></title>
    <url>%2F2019%2F01%2F16%2FMFCCExplore%2F</url>
    <content type="text"><![CDATA[毕业设计进展报告五——陶家成一周主要工作内容 了解特征提取的过程 了解MFCC及其实现原理 了解HMM 打了一些codeforces的题 《语音信号处理》、《Automatic Speech Recognition》 未完成： 了解傅立叶变换及其在深度学习中的应用 具体内容关于音频特征MFCC提取MFCC概述 根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉敏感度。所以，人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPCC相比具有更好的鲁邦性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。 梅尔倒谱系数是在Mel标度频率域提取出来的倒谱参数，Mel标度描述了人耳频率的非线性特性，它与频率的关系可用下式近似表示： ​ $Mel(f) = 2595 · lg(1 + f/700)$ Mel频率与线性频率的关系： MFCC特征提取过程包括 对音频信号预加重、分帧和加窗 FFT(快速傅里叶变换)得到频谱 频谱通过Mel滤波器组得到Mel频谱 在Mel频谱上面进行倒谱分析得到MFCC特征 通过这个MFCC特征提取过程，语音就可以通过一系列的倒谱向量来描述了，每个向量就是每帧的MFCC特征向量。语音识别系统就可以接着在MFCC特征的基础上进行训练和识别了。 预加重 预加重的目的是提升高频部分，对语音的高频部分进行加重，去除口唇辐射的影响，增加语音的高频分辨率使信号的频谱变得平坦，保持在低频到高频的整个频带中，能用同样的信噪比求频谱。原因是因为对于语音信号来说，语音的低频段能量较大，能量主要分布在低频段，语音的功率谱密度随频率的增高而下降，这样，鉴频器输出就会高频段的输出信噪比明显下降，从而导致高频传输衰弱，使高频传输困难，这对信号的质量会带来很大的影响。因此，在传输之前把信号的高频部分进行加重，然后接收端再去重，能够提高信号传输质量。 预加重相当于图片处理中的灰度拉伸/二值化，「增加识别的准确性」 预加重其实是将语音信号通过一个高通滤波器： $x_p(n) = x(n) - k·(n-1)$ （任取k，但是语音处理通常用0.9-0.97） 分帧 语音信号的变化是非常迅速的，但是通常傅里叶变换适用于分析平稳的信号。我们假设在较短的时间跨度范围内，语音信号的变换是平坦的，一般取这个时间跨度为20ms-40ms。为什么取这个范围呢，因为能够保证一帧内既有足够多的周期，又不会变化太剧烈。 为了「分离平滑帧」 加窗 每帧信号通常要与一个平滑的窗函数相乘，让帧两端平滑地衰减到零，这样可以降低傅里叶变换后旁瓣的强度，取得更高质量的频谱。对每一帧，选择一个窗函数，窗函数的宽度就是帧长。常用的窗函数有矩形窗、汉明窗、汉宁窗、高斯窗等。 为了「取得更高质量的频谱」 假设分帧后的信号为S(n), n=0,1…,N-1, N为帧的大小，那么乘上汉明窗 后，W(n)的形式如下： FFT(快速傅立叶变换) 由于信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察，不同的能量分布，就能代表不同语音的特性。所以在乘上汉明窗后，每帧还必须再经过快速傅里叶变换以得到在频谱上的能量分布。 得到「频谱的能量分布」 对语音信号频谱取模平方得到语音信号谱线能量。 声谱图「重点部分」声谱图的作用： 音素以及它们的属性更易于观察 通过观察共振峰和它们的转变可以更好的识别声音 隐马尔科夫模型就是隐含地对声谱图进行建模以达到好的识别性能 能够直观的评估TTS系统（text to speech）的好坏，直接对比合成的语音和自然的语音声谱图的匹配度即可 经过前面的预处理，每帧语音都对应一个频谱。 「但是这部分还是看不太懂」 计算通过Mel滤波器的能量将能量谱通过一组Mel尺度的三角形滤波器组，定义一个有M个滤波器的滤波器组（滤波器的个数和临界带的个数相近），采用的滤波器为三角滤波器，中心频率为f(m) 。M通常取22-26。各f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，如图所示： 对频谱进行平滑化，并消除谐波的作用，突显原先语音的共振峰。（因此一段语音的音调或音高，是不会呈现在MFCC 参数内，换句话说，以MFCC 为特征的语音辨识系统，并不会受到输入语音的音调不同而有所影响）此外，还可以降低运算量。 三角滤波器的频率响应定义为: 计算每个滤波器组输出的对数能量为 ： 计算DCT倒谱经离散余弦变换（DCT）得到MFCC系数 : 将上述的对数能量带入离散余弦变换，求出L阶的Mel参数。L阶指MFCC系数阶数，通常取12-16。这里M是三角滤波器个数。 在六大区实现的官方源码中使用HTK实现MFCC和HMM 整个HTK是使用HMM作为语音识别的核心，当HMM应用于孤立词语音识别时，它用不同的隐含状态来描述不同的语音发音，对于连续语音识别系统，多个孤立词HMM子模型按一定的语言模型组成的复合HMM模型序列来刻画连续的语音信号，在序列中每个模型直接对应于相关的发音，并且每一个模型都有进入和退出状态，这两个状态没有对应的观察矢量，只用于不同模型的连接。 HTK是英国剑桥大学开发的一套基于C语言的隐马尔科夫模型工具箱，主要应用于语音识别、语音合成的研究，也被用在其他领域，如字符识别和DNA排序等。HTK是重量级的HMM版本。 代码位置：inferenceLSTM/read_data和inferenceLSTM/HTKfile HTK文件结构：帧数：4字节（第0-第3字节） 采样周期：4字节（第4-第7字节） 每一帧的字节数：2字节（第8-第9字节） 参数类型：2字节（第10-第11字节） 数据：N字节（第12字节开始-文件结尾） TODO 把文件中的主要代码和预处理脚本都理清看懂 完成采集数据集的准备工作，弄清音频的要求 弄懂声谱图部分，性能调优的方向之一 看书《深度学习中文版》 第三章——概率与信息论 第八章——深度模型中的优化 第十章——循环和递归网络——LSTM 学好算法，打打codeforces ADD 了解傅立叶变换及其在深度学习中的应用]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语音识别初实现]]></title>
    <url>%2F2019%2F01%2F04%2FASRExplore%2F</url>
    <content type="text"><![CDATA[语音识别初实现——傅立叶变换、MFCC、HMM读取和绘制音频数据 读取音频文件并可视化展现 音频文件是实际音频信哈的数字化形式，实际的音频信号是复杂的连续波形。为了将其保存成数字化形式，需要对音频信号进行采样并将其转换成数字。语音通常以44100 Hz的频率进行采样，这就意味着每秒钟信号被分解成44100份，然后这些抽样值被保存。 代码实现：123456789101112131415161718192021222324252627282930import numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfile# 使用wavfile包从input_read.wav中读取音频文件:sampling_freq, audio = wavfile.read('input_read.wav')# 打印信号相关参数print ('\nShape:', audio.shape)print ('Datatype:', audio.dtype)print ('Duration:', round(audio.shape[0] / float(sampling_freq), 3), 'seconds')# 标准化audio = audio / (2.**15)# 提取前30个值画图audio = audio[:30]# 建立时间轴，x轴按照采样频率因子进行缩放x_values = np.arange(0, len(audio), 1) / float(sampling_freq)# 单位转换为secondsx_values *= 1000# 画出声音信号图形plt.plot(x_values, audio, color='black')plt.xlabel('Time (ms)')plt.ylabel('Amplitude')plt.title('Audio signal')plt.show() 将音频信号转化为频域 音频信号是不同频率、幅度和相位的正弦波的复杂混合。正弦波也称作正弦曲线。音频信号的频率内容中隐藏了很多信息。事实上，一个音频信号的性质由其频率内容决定。世界上的语音和音乐都是基于这个事实的。 //Todo 傅立叶变换 123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npfrom scipy.io import wavfileimport matplotlib.pyplot as plt# Read the input filesampling_freq, audio = wavfile.read('input_freq.wav')# Normalize the valuesaudio = audio / (2.**15)# 提取数组长度len_audio = len(audio)# 傅立叶变换，因为傅立叶变换是关于中心点对称的，因此只需要转换信号的前半部分。# 最终目标是提取功率信号，先将信号的值平方transformed_signal = np.fft.fft(audio)half_length = np.ceil((len_audio + 1) / 2.0)transformed_signal = abs(transformed_signal[0:half_length])transformed_signal /= float(len_audio)transformed_signal **= 2# 提取信号长度len_ts = len(transformed_signal)# 将部分信号乘以2if len_audio % 2: transformed_signal[1:len_ts] *= 2else: transformed_signal[1:len_ts-1] *= 2# 获取功率信号power = 10 * np.log10(transformed_signal)# Build the time axisx_values = np.arange(0, half_length, 1) * (sampling_freq / len_audio) / 1000.0# Plot the figureplt.figure()plt.plot(x_values, power, color='black')plt.xlabel('Freq (in kHz)')plt.ylabel('Power (in dB)')plt.show() 提取频域特征 将信号转换为频域之后，还需要将其转换成有用的形式。梅尔频率倒谱系数(Mel Frequency Cepstrum Coefficient，MFCC)可以解决这个问题。MFCC首先计算信号的功率谱，然后用滤波器组和离散余弦变换的组合来提取特征。 //Todo 梅尔频率倒谱系数 1234567891011121314151617181920212223242526272829303132import numpy as npimport matplotlib.pyplot as pltfrom scipy.io import wavfile from features import mfcc, logfbank# Read input sound filesampling_freq, audio = wavfile.read("input_freq.wav")# Extract MFCC and Filter bank features# 提取MFCC和过滤器组特征mfcc_features = mfcc(audio, sampling_freq)filterbank_features = logfbank(audio, sampling_freq)# Print parameters# 查看可以生成多少个窗体print ('\nMFCC:\nNumber of windows =', mfcc_features.shape[0])print ('Length of each feature =', mfcc_features.shape[1])print ('\nFilter bank:\nNumber of windows =', filterbank_features.shape[0])print ('Length of each feature =', filterbank_features.shape[1])# Plot the features# 画出特征图mfcc_features = mfcc_features.Tplt.matshow(mfcc_features)plt.title('MFCC')# 滤波器组特征可视化，需要转换矩阵，使得域是水平的filterbank_features = filterbank_features.Tplt.matshow(filterbank_features)plt.title('Filter bank')plt.show() 创建一个隐马尔可夫模型 本例将用到隐马尔科夫模型(Hidden Markov Models，HMMs)来做语音识别。隐马尔科夫模型非常擅长建立时间序列数据模型。因为一个音频信号同时也是一个时间序列信号，因此隐马尔科夫模型也同样适用于音频信号的处理。假定输出是通过隐藏状态生成的，我们的目标是找到这些隐藏状态，以便对信号建模。 // Todo 隐马尔科夫模型 创建一个语音识别器 我们需要为每一类构建一个隐马尔科夫模型。如果想识别新的输入文件中的单词，需要对该文件运行所有的模型，并找出最佳分数的结果。下面将用到在前一节构建的隐马尔科夫类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import osimport argparse import numpy as npfrom scipy.io import wavfile from hmmlearn import hmmfrom features import mfcc# 用于解析命令行中输入的参数def build_arg_parser(): parser = argparse.ArgumentParser(description='Trains the HMM classifier') parser.add_argument("--input-folder", dest="input_folder", required=True, help="Input folder containing the audio files in subfolders") return parser# 创建类处理HHM相关过程class HMMTrainer(object): # 初始化该类。下面将用到高斯隐马尔科夫模型(Gaussian HMMs)来对数据建模。参数 n_components定义了隐藏状态的个数，参数cov_type定义了转移矩阵的协方差类型，参数 n_iter定义了训练的迭代次数 def __init__(self, model_name='GaussianHMM', n_components=4, cov_type='diag', n_iter=1000): # 初始化变量 self.model_name = model_name self.n_components = n_components self.cov_type = cov_type self.n_iter = n_iter self.models = [] # 用以下参数定义模型 if self.model_name == 'GaussianHMM': self.model = hmm.GaussianHMM(n_components=self.n_components, covariance_type=self.cov_type, n_iter=self.n_iter) else: raise TypeError('Invalid model type') # 输入数据是一个NumPy数组，数组的每个元素都是一个特征向量，每个特征向量都包含k 个维度 # X is a 2D numpy array where each row is 13D def train(self, X): np.seterr(all='ignore') self.models.append(self.model.fit(X)) # 基于该模型定义一个提取分数的方法 # Run the model on input data def get_score(self, input_data): return self.model.score(input_data) # 定义一个main函数，解析输入的参数if __name__=='__main__': args = build_arg_parser().parse_args() input_folder = args.input_folder # 初始化隐马尔科夫模型的变量 hmm_models = [] # 解析包含所有数据库音频文件的输入路径 for dirname in os.listdir(input_folder): # 提取子文件夹的名称 subfolder = os.path.join(input_folder, dirname) if not os.path.isdir(subfolder): continue # 子文件夹的名称即为该类的标记，提取标记 label = subfolder[subfolder.rfind('/') + 1:] # 初始化变量 X = np.array([]) y_words = [] # 迭代每一个子文件夹中的音频文件（分别保留一个进行测试） for filename in [x for x in os.listdir(subfolder) if x.endswith('.wav')][:-1]: # 读取每个音频文件 filepath = os.path.join(subfolder, filename) sampling_freq, audio = wavfile.read(filepath) # 提取MFCC特征 mfcc_features = mfcc(audio, sampling_freq) # 将MFCC特征添加到X变量 if len(X) == 0: X = mfcc_features else: X = np.append(X, mfcc_features, axis=0) # 添加标记 y_words.append(label) print 'X.shape =', X.shape # 一旦提取完当前类所有文件的特征，就可以训练并保存隐马尔科夫模型了。因为隐马尔科夫模型是一个无监督学习的生成模型，所以并不需要利用标记针对每一类构建隐马尔科夫模型。 # Train and save HMM model hmm_trainer = HMMTrainer() hmm_trainer.train(X) hmm_models.append((hmm_trainer, label)) hmm_trainer = None # Test files（获取一个未被用于训练的测试文件列表） input_files = [ 'data/pineapple/pineapple15.wav', 'data/orange/orange15.wav', 'data/apple/apple15.wav', 'data/kiwi/kiwi15.wav' ] # 为输入数据分类 for input_file in input_files: # Read input file sampling_freq, audio = wavfile.read(input_file) # 提取MFCC特征 mfcc_features = mfcc(audio, sampling_freq) # Define variables max_score = None output_label = None # 迭代HMM模型并选取得分最高的模型 # the one with the highest score for item in hmm_models: hmm_model, label = item # 提取并保存最大分数 score = hmm_model.get_score(mfcc_features) if score &gt; max_score: max_score = score output_label = label # Print the output print "\nTrue:", input_file[input_file.find('/')+1:input_file.rfind('/')] print "Predicted:", output_label]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习初探]]></title>
    <url>%2F2019%2F01%2F03%2FDLWithPyFirstExlpore%2F</url>
    <content type="text"><![CDATA[深度学习初探——基于Python的理论和实现此书特点： 从零开始实现深度学习程序 最终实现一个高精度识别图像的系统 从实现层面理解误差反向传播法、卷积运算 不介绍深度学习框架 不介绍参数调优 不进行GPU相关实现 目标：有能力进一步去阅读最新的论文或者神经网络相关的理论方面的技术书。 Python入门Numpy 在深度学习的实现中，经常出现数组和矩阵的计算。NumPy 的数组类 (numpy.array)中提供了很多便捷的方法，在实现深度学习时，我们将使用这些方法。 导入Numpy库Python中使用import语句来导入库。这里的import numpy as np，直译的话就是“将 numpy 作为 np 导入”的意思。通过写成这样的形式，之后NumPy 相关的方法均可通过 np 来调用。 生成Numpy数组生成 NumPy 数组，需要使用 np.array() 方法。 Numpy的算数运算当数组 x 和数组 y 的元素个数相同时，可以对各个元素进行算术运算。 Numpy的N维数组1A = np.array([[1, 2], [3, 4]]) 广播形状不同的数组之间也可以进行运算。标量数组扩展成2*2数组再计算，称之为广播。 访问元素逐个访问，for语句访问，数组访问 Matplotlib 在深度学习的实验中，图形的绘制和数据的可视化非常重要。Matplotlib是用于绘制图形的库，使用 Matplotlib 可以轻松地绘制图形和实现数据的可视化。 pyplot的功能添加标题和x轴标签名等功能 1234567891011121314151617# coding: utf-8import numpy as npimport matplotlib.pyplot as plt# 生成数据x = np.arange(0, 6, 0.1) # 以0.1为单位，生成0到6的数据y1 = np.sin(x)y2 = np.cos(x)# 绘制图形plt.plot(x, y1, label="sin")plt.plot(x, y2, linestyle = "--", label="cos")plt.xlabel("x") # x轴的标签plt.ylabel("y") # y轴的标签plt.title('sin &amp; cos')plt.legend()plt.show() 显示图像pyplot提供了用于显示图像的方法imshow()。另外，可以使用matplotlib.image 模块的 imread() 方法读入图像。 12345678# coding: utf-8import matplotlib.pyplot as pltfrom matplotlib.image import imreadimg = imread('../dataset/lena.png') #读入图像plt.imshow(img)plt.show() 图像放在dataset目录下，可以直接读取。 感知机感知机是什么？ 感知机是作为神经网络(深度学习)的起源的算法。感知机接收多个输入信号，输出一个信号。这里所说的“信号”可以想象成电流或河流那样具备“流动性”的东西。像电流流过导线，向前方输送电子一样，感知机的信号也会形成流，向前方输送信息。但是，和实际的电流不同的是，感知机的信号只有“流 / 不流”(1/0)两种取值。 x1、x2 是输入信号，y是输出信号，w1、w2 是权重(w是weight的首字母)。图中的○称为“神经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重(w1x1、w2x2)。神经元会计算传送过来的信号的总和，只有当这个总和超过了某个界限值时，才会输出1。这也称为“神经元被激活”。b称为偏置的参数，用于控制神经元被激活的容易程度。 数学表示： 感知机多个输入信号有各自的权重，这些权重发挥着控制着各个信号的重要性的作用。权重越大，信号的重要性就越高。（权重相当于电流中的电阻，电阻决定电流流动难度的参数） 简单逻辑电路我们已经知道使用感知机可以表示与门、与非门、或门的逻辑电路。这里重要的一点是:与门、与非门、或门的感知机构造是一样的。实 际 上 ， 3 个门电路只有参数的值(权重和阈值)不同 。 感知机的实现使用权重和偏置实现与门： 123456789101112131415161718# coding: utf-8import numpy as npdef AND(x1, x2): x = np.array([x1, x2]) w = np.array([0.5, 0.5]) b = -0.7 tmp = np.sum(w*x) + b if tmp &lt;= 0: return 0 else: return 1if __name__ == '__main__': for xs in [(0, 0), (1, 0), (0, 1), (1, 1)]: y = AND(xs[0], xs[1]) print(str(xs) + " -&gt; " + str(y)) 使用感知机可以实现与门、与非门、或门三种逻辑电路。 感知机的局限性 感知机无法实现异或门 感知机无法表示曲线 多层感知机 通过组合与门、与非门、或门实现异或门 通过叠加层(加深层)，感知机能进行更加灵活的表示。 神经网络 感知机的作用是：即便对于复杂的函数，也隐含着能够表示它的可能性。神经网络的一个重要性质是可以自动从数据中学习合适的权重参数。 从感知机到神经网络神经网络的例子用图来表示神经网络，分为输入层、输出层和中间层。中间层也叫隐藏层，隐藏层的神经元肉眼看不见。神经元的连接方式而言，与感知机并无差别。 复习感知机明确表示出偏置，简化式子，引入新函数h(x) ： 激活函数h(x)函数会将输入信号的总和转换为输出信号，这种函数一般称为激活函数(activation function)。激活函数的作用在于决定如何来激活输入信号的总和。 先计算输入信号的加权总和，然后用激活函数转换这一总和： 明确显示激活函数计算过程的神经元 ： 信号的加权总和为节点 a，然后节点 a 被激活函数 h() 转换成节点 y。“神经元”和“节点”两个术语的含义相同。 激活函数是连接感知机和神经网络的桥梁。 激活函数 激活函数以阈值为界，一旦输入超过阈值，就切换输出。这样的函数称为“阶跃函数”。因此，可以说感知机中使用了阶跃函数作为激活函数。也就是说，在激活函数的众多候选函数中，感知机使用了阶跃函数。那么，如果感知机使用其他函数作为激活函数的话会怎么样呢?实际上，如果将激活函数从阶跃函数换成其他函数，就可以进入神经网络的世界了。 sigmoid函数神经网络经常使用的一个激活函数sigmoid函数： 神经网络利用sigmoid函数作为激活函数，进行信号的转换，转换后的信号被传送到下一个神经元。感知机和神经网络的主要区别就在于这个激活函数。在其它方面，比如神经元的多层连接的构造，信号的传递方法等，基本上和感知机是一样的。 阶跃函数的实现简单的阶跃函数： 12345def step_function(x): if x &gt; 0: return 1 else: return 0 支持NumPy数组的实现： 123def step_function(x): y = x &gt; 0 return y.astype(np.int) NumPy数组进行不等号运算后，数组的各个元素都会进行不等号运算，生成一个布尔型的数组。数组y是个布尔型的数组，但是阶跃函数是会输出int型的0或1的函数。因此需要转换为int型。 可以用 astype() 方法转换 NumPy 数组的类型。astype() 方法通过参数指定期望的类型，这个例子中是 np.int 型。 阶跃函数的图形图形上表示上面定义的阶跃函数，需要用到matplotlib库： 12345678910111213import numpy as npimport matplotlib.pylab as pltdef step_function(x): return np.array(x &gt; 0, dtype = np.int)#−5.0到5.0的范围内，以0.1为单位，生成 NumPy数组([-5.0, -4.9, ..., 4.9])x = np.arange(-5.0,5.0,0.1)#step_function()以该NumPy数组为 参数，对数组的各个元素执行阶跃函数运算，并以数组形式返回运算结果。y = step_function(x)plt.plot(x,y)plt.ylim(-0.1,1.1) #指定y轴的范围plt.show() 阶跃函数以 0 为界，输出从 0 切换为 1(或者从 1 切换为 0)。 它的值呈阶梯式变化，所以称为阶跃函数。 sigmoid函数的实现12345def sigmoid(x): return 1 / (1 + np.exp(-x))x = np.array([-1.0, 1.0, 2.0])sigmoid(x) 在python中可以如此表示sigmoid函数，当传入参数x为NumPy数组时，也能被正确计算，是因为NumPy的广播功能。 现在把上面的阶跃函数换成sigmoid函数： sigmoid函数和阶跃函数的比较： sigmoid函数是一条平滑的曲线，输入输出发生连续的变化。阶跃则是以0为界，急剧变化。 阶跃函数只能返回0和1，sigmoid函数可以返回实数 都是非线性函数： 激活函数不能使用线性函数，使用线性函数，加深网络的层数就没有意义了。 线性函数无法发挥多层网络带来的优势 ReLU函数sigmoid早就开始用了，现在主要使用ReLU（Rectified Linear Unit）函数。 ReLU函数输入大于 0 时，直接输出该值;在输入小于等于 0 时，输出 0 ： ReLU函数的实现： 12def relu(x): return np.maximum(0,x) 多维数组的运算多维数组运算可以高效实现神经网络 二维矩阵1B = np.array([[1,2], [3,4], [5,6]]) 矩阵的乘积：（np.dot(A, B)和np.dot(B, A)不同） 123A = np.array([[1,2], [3,4]])B = np.array([[5,6], [7,8]])np.dot(A, B) A的列数必须和B的行数相等才能计算np.dot(A,B) 神经网络的内积使用NumPy矩阵实现神经网络：（省略了偏置和激活函数，只有权重） 三层神经网络的实现巧妙使用NumPy数组，可以使用很少的代码实现神经网络的前向处理。 符号确认 表示前一层的第 2 个神经元 x2 到后一层的第 1 个神经元 的权重。w(weight) 各层间信号传递的实现 矩阵乘法运算，则可以表示成： 代码简单实现上述式子： 123456X = np.array([1.0, 0.5])W1 = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) B1 = np.array([0.1, 0.2, 0.3])A1 = np.dot(X, W1) + B1 #x的列数和w的行数相同，w和x对应维度的个数也保持一致#前面的乘积的到一个3列，加上B的3列 隐藏层的加权和(加权信号和偏置的总和)用 a 表示，被激活函数转换后的信号用 z 表示。此外，图中 h() 表示激活函数，这里我们使用的是 sigmoid 函数： 1234Z1 = sigmoid(A1)print(A1)print(Z1) 下面实现第一层到第二层的信号传递： 1234567W2 = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])B2 = np.array([0.1, 0.2])print(Z1.shape) # (3,) print(W2.shape) # (3, 2) print(B2.shape) # (2,)A2 = np.dot(Z1, W2) + B2 Z2 = sigmoid(A2) 实现基本相同，但是最后的激活函数和隐藏层的有所不同。 12345678def identity_function(x): return xW3 = np.array([[0.1, 0.3], [0.2, 0.4]]) B3 = np.array([0.1, 0.2])A3 = np.dot(Z2, W3) + B3Y = identity_function(A3) # 或者Y = A3 这里的identity_function()函数（恒等函数），并将其作为输出层的激活函数。这样实现只是为了和之前的流程保持统一。 输出层所用的函数：根据求解问题的性质决定： 回归问题用恒等函数 二元分类问题使用sigmoid函数 多元分类问题使用softmax函数 代码实现小结12345678910111213141516171819202122232425def init_network(): #初始化为字典变量&#123;&#125; network = &#123;&#125; network['W1'] = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]]) network['b1'] = np.array([0.1, 0.2, 0.3]) network['W2'] = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]]) network['b2'] = np.array([0.1, 0.2]) network['W3'] = np.array([[0.1, 0.3], [0.2, 0.4]]) network['b3'] = np.array([0.1, 0.2]) return networkdef forward(network,x): W1, W2, W3 = network['W1'], network['W2'], network['W3'] b1, b2, b3 = network['b1'], network['b2'], network['b3'] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2, W3) + b3 y = identity_function(a3) return ynetwork = init_network()x = np.array([1.0, 0.5])y = forward(network, x)print(y) # [ 0.31682708 0.69627909] 定义了init_network()和forward()函数，分别进行权重的初始化和信号处理。后面会有backword()处理函数（从输出往输入方向的处理）。通过NumPy的多维数组，高效地实现了神经网络。 输出层的设计神经网络可以用在分类问题和回归问题上，需要根据情况改变输出层的激活函数，回归问题用恒等函数，分类问题用softmax函数。 恒等函数和softmax 函数和前面隐藏层的激活函数一样，恒等函数进行的转换处理可以用一根箭头表示。 分类问题中的softmax函数可以用下面的式子表示： softmax 函数的分子是输入信号 ak 的指数函数，分母是所有输入信号的指数函数的和。 softmax函数的输出通过肩头和所有的信号相连，输出层的各个神经元都受到输入信号的影响。 softmax函数的实现： 123456def softmax(a): exp_a = np.exp(a) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y 实现softmax函数的注意事项上面的softmax的实现存在溢出问题，指数运算的值很容易溢出，如果超大的值进行除法运算就会出现不确定的情况。溢出问题在进行计算的运算时必须注意！ 改进： 指数运算时加上某个常数并不会改变运算结果，这里的C‘为了防止溢出，一般使用输入信号中的最大值的相反数。 softmax改进后的函数实现： 1234567def softmax(a): c = np.max(a) exp_a = np.exp(a-c) sum_exp_a = np.sum(exp_a) y = exp_a / sum_exp_a return y softmax的函数特征 因为指数函数是单调递增函数，即便使用了softmax函数各个元素之间的大小关系也不会改变。一般来说，神经网络只把输出值最大的神经元对应的类别作为识别结果。即便使用softmax函数，输出值最大的神经元也不会改变，在神经网络分类时，softmax函数可以省略。 求解机器学习问题的步骤可以分为“学习”A 和“推理”两个阶段。首先，在学习阶段进行模型的学习 B，然后，在推理阶段，用学到的模型对未知的数据进行推理(分类)。如前所述，推理阶段一般会省略输出层的 softmax 函数。在输出层使用 softmax 函数是因为它和神经网络的学习有关系。 softmax的函数输出总是在0.0到1.0之间 softmax函数的输出值总和为1，所以softmax可以解释为概率。 通过使用softmax函数，可以使用概率论统计的方法处理问题 输出层神经元数量输出层的神经元数量需要根据待解决的问题来决定。对于分类问题，输出层的神经元数量一般设定为类别的数量。 手写数字识别使用学习到的参数，先实现神经网络的“推理处理”。这个推理处理也称为神经网络的前向传播(forward propagation)。 MNIST数据集什么是MNIST？ MNIST手写数据集，是机器学习最有名的数据集之一。MNIST有训练图像6w张，测试图像1w张。 一般使用方法：先用训练图像进行学习，再用学习到的模型度量能够多大程度上对测试图像进行正确的分类。 MNIST图像数据是28像素x28像素的灰度图像，各个像素取值在0-255之间，每个图像对应有数字标签。 ch03/mnist_show.py使用mnist.py中的load_mnist()函数，就可以读取MNIST数据： 1234567891011121314151617181920212223242526# coding: utf-8import sys, ossys.path.append(os.pardir) # 为了导入父目录的文件而进行的设定import numpy as npfrom dataset.mnist import load_mnist # 调入自定义的load_mnist函数from PIL import Imagedef img_show(img): # Image.fromarray把保存为 NumPy 数组的图像数据转换为 PIL 用 的数据对象 pil_img = Image.fromarray(np.uint8(img)) pil_img.show()(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False)# 当flatten=True时读入的图像是以一列NumPy数组的形式保存的，显示图像时需要调用reshape()方法img = x_train[0]label = t_train[0]print(label) # 5print(img.shape) # (784,)img = img.reshape(28, 28) # 通过 reshape() 方法的参数指定期望的形状，更改 NumPy 数组的形状。print(img.shape) # (28, 28)img_show(img) 关于PIL（Python Image Library）是Python的图像处理标准库，功能非常强大，API简单易用。 PIL中的Image和NumPy中的array相互转换 PIL Image转换为array 1img = np.asarray(image 如果出现read-only错误，并不是转换的错误，一般是你读取的图片的时候，默认选择的是”r”,”rb”模式有关。 1img.flags.writeable = True # 将数组改为读写模式 array转换成image 1Image.fromarray(np.unit8(img)) 关于load_mnist函数的解释位于dataset/mnist.py的load_mnist`函数： 123456789101112131415161718192021222324def load_mnist(normalize=True, flatten=True, one_hot_label=False): # 如果数据不存在，调用init方法下载并转换 if not os.path.exists(save_file): init_mnist() # with能够自动处理上下文环境产生的异常 with open(save_file, 'rb') as f: dataset = pickle.load(f) if normalize: for key in ('train_img', 'test_img'): dataset[key] = dataset[key].astype(np.float32) dataset[key] /= 255.0 if one_hot_label: dataset['train_label'] = _change_one_hot_label(dataset['train_label']) dataset['test_label'] = _change_one_hot_label(dataset['test_label']) if not flatten: for key in ('train_img', 'test_img'): dataset[key] = dataset[key].reshape(-1, 1, 28, 28) return (dataset['train_img'], dataset['train_label']), (dataset['test_img'], dataset['test_label']) 通过传入布尔值来执行相关操作的函数： normalize（正规化）：将图像的像素值正规化为0.0~1.0。 将图像的各个像素值除以 255，使得数据的值在 0.0~1.0 的范围内。像这样把数据限定到某个范围内的处理称为正规化(normalization)。 flatten（扁平化）：是否将图像展开为一维数组。 one_hot_label（一条标签数组）：one_hot_label为True的情况下，标签作为one-hot数组返回。「one-hot数组是指[0,0,1,0,0,0,0,0,0,0]这样的数组」 读入MNIST数据集，返回(训练图像, 训练标签), (测试图像, 测试标签) 神经网路的推理处理神经网络输入层有784个神经元，输出层有10个神经元，输入层784源于图像大小28 x 28，输出层的10来源于10类别分类。此外还有两个隐藏层，第一层50个神经元，第二层100个神经元。50和100可以为任意值。 定义 get_data()、init_network()、predict() ：【neuralnet_mnist.py】 1234567891011121314151617181920212223242526272829303132333435363738394041424344# coding: utf-8import sys, ossys.path.append(os.pardir) # 为了导入父目录的文件而进行的设定import numpy as npimport picklefrom dataset.mnist import load_mnistfrom common.functions import sigmoid, softmax# 返回测试图像和测试标签def get_data(): (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, flatten=True, one_hot_label=False) return x_test, t_test# 读入保存在pickle文件sample_weight.pkl中的权重参数，这个文件以字典变量的形式保存了权重和偏置参数def init_network(): with open("sample_weight.pkl", 'rb') as f: network = pickle.load(f) return networkdef predict(network, x): W1, W2, W3 = network['W1'], network['W2'], network['W3'] b1, b2, b3 = network['b1'], network['b2'], network['b3'] a1 = np.dot(x, W1) + b1 z1 = sigmoid(a1) a2 = np.dot(z1, W2) + b2 z2 = sigmoid(a2) a3 = np.dot(z2, W3) + b3 y = softmax(a3) return yx, t = get_data() # 取出数据network = init_network()accuracy_cnt = 0for i in range(len(x)): y = predict(network, x[i]) p= np.argmax(y) # 获取概率最高的元素的索引 if p == t[i]: accuracy_cnt += 1print("Accuracy:" + str(float(accuracy_cnt) / len(x))) 这三个函数实现了神经网络的推理处理，然后评价识别精度（accuracy）： 获取MNIST的数据集，生成网络。 用 for 语句逐一取出保存在 x 中的图像数据，用 predict() 函数进行分类。「predict() 函数以 NumPy 数组的形式输出各个标签对应的概率」 取出这个概率列表中的最大值的索引，作为预测结果。「np.argmax(x) 将获取被赋给参数 x 的数组中的最大值元素的索引」 比较神经网络所预测的答案和正确解标签，将回答正确的概率作为识别精度 「注:」此处是假设学习已经完成，学习中的参数保存在sample_weight.pkl文件中，在推理阶段，直接加载这些学习到的参数 在刚才的例子中，作为一种预处理，我们将各个像素值除以 255，进行了简单的正规化。实际上，很多预处理都会考虑到数据的整体分布。比如，利用数据整体的均值或标准差，移动数据，使数据整体以 0 为中心分布，或者进行正规化，把数据的延展控制在一定范围内。除此之外，还有将数据整体的分布形状均匀化的方法，即数据白化(whitening)等。 批处理多维数组对应维度的元素个数一致，输入由784个元素组成的一维数组，最终输出元素个数为10的一维数组： 这是只输入一张图像数据时的处理流程。 比如，我们想用 predict()函数一次性打包处理 100 张图像。为此，可以把 x 的形状改为 100 × 784，将100 张图像打包作为输入数据： 此时，输入的100张图像的结果被一次性输出了。 12345678910111213x, t = get_data()network = init_network()batch_size = 100 # 批数量accuracy_cnt = 0for i in range(0, len(x), batch_size): x_batch = x[i:i+batch_size] y_batch = predict(network, x_batch) p = np.argmax(y_batch, axis=1) accuracy_cnt += np.sum(p == t[i:i+batch_size])print("Accuracy:" + str(float(accuracy_cnt) / len(x))) 批处理代码实现中的不同之处： 首先是range()函数： range(start, end)生成一个start到end-1之间的整数构成的列表 range(start, end, step)下一个元素会增加step x[i:i+batch_n]会取出从第 i 个到第 i+batch_n 个之间的数据。 通过 argmax() 获取值最大的元素的索引。不过这里需要注意的是，我们给定了参数 axis=1。这指定了在 100 × 10 的数组中，沿着第 1 维方向(以第 1 维为轴)找到值最大的元素的索引(第 0 维对应第 1 个维度)。 最后，比较一下以批为单位进行分类的结果和实际的答案 本章介绍的神经网络和上一章的感知机在信号的按层传递这一点上是相同的，但是，向下一个神经元发送信号时，改变信号的激活函数有很大差异。神经网络中使用的是平滑变化的 sigmoid函数，而感知机中使用的是信号急剧变化的阶跃函数。 神经网络学习 “学习”是指从训练数据中自动获取最优权重参数的过程。为了使神经网络能进行学习，将导入损失函数这一指标。而学习的目的就是以该损失函数为基准，找出能使它的值达到最小的权重参数。为了找出尽可能小的损失函数的值，利用了函数斜率的梯度法。 误差反向传播法 数值微分虽然简单，也容易实现，但缺点是计算上比较费时间。误差反向传播法能够高效计算权重参数的梯度。正确理解误差反向传播法，有两种方法：数学式和计算图 与学习相关的技巧 神经网络的学习中一些重要观点，主题涉及寻找最优权重参数的最优化方法、权重参数的初始值、超参数设定方法等。为了应对过拟合，还将介绍权值衰减、Dropout 等正则化方法，并进行实现。 卷积神经网络 本章主题是卷积神经网络（CNN），CNN用于图像识别、语音识别等场合，在图像识别比赛中，基于深度学习的方法几乎都以CNN为基础。 深度学习 深度学习是加深了层的深度神经网络。基于之前介绍的网络，只需通过叠加层，就可以创建深度网络。 关于神经网络，已经学了很多：构成神经网络的各种层、学习时的有效技巧、对图像特别有效的CNN、参数的最优方法等。本章将这些知识汇总起来，创建一个深度网络，挑战MNIST数据集的手写数字识别。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heart of a Lio]]></title>
    <url>%2F2018%2F10%2F17%2FLioMessi%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Videos/Gatorade%20-%20Heart%20of%20a%20Lio.mp4"},"danmaku":{"id":"LioMessi","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>Inspirational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM02-Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F10%2F05%2FJVMpro02%2F</url>
    <content type="text"><![CDATA[概述对C、C++开发人员来说，在内存管理领域，他们有着最高的权力，但同时肩负着每一个对象从开始到终结的维护责任。而对于Java程序员而言，由于JVM的自动内存管理机制，Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将为成为一项十分艰难的工作。 运行时数据区域Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区。下面详细阐述各数据区所存储的数据类型。 程序计数器(Program Counter Register) 作用：记录当前线程所执行到字节码的行号。字节码解释器工作的时就是通过改变这个计数器的值来选取下一条所需要执行的字节码指令。 意义：由于JVM的多线程是通过线程轮换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。所以为了实现并行，并保证各个线程指令安全顺利执行，每条线程都需要有一个独立的程序计数器。 记录内容： 如果线程正在执行一个Java方法，计数器记录的是正在执行的虚拟字节码指令的地址。 如果正在执行Native方法，计数器值为空(Undefined)。 可能出现的异常：此内存区域是唯一一个在Java虚拟机规范中没有任何内存溢出异常(OutOfMemoryError)的区域。 Java虚拟机栈(Java Virtual Machine Stacks) Java内存区常被分为堆内存（Heap）和栈内存（Stack），其中栈内存其实指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分 作用：虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个线帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点： Java虚拟机栈也是线程私有的，它的生命周期与线程相同。 每一个方法从调用直至执行完成的过程就对应着一个线帧在虚拟机栈中从入栈到出栈的过程。 存储内容： 局部变量表，包括编译期可知的各种基本数据类型、对象引用(reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或次对象相关位置)、指向一条字节码指令的returnAddress类型 值得注意的是：局部变量表所需的内存空间在编译期间完成分配。在方法运行的阶段是不会改变局部变量表的大小的 可能出现的异常： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果在动态扩展内存的时候无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈(Native Method Stack) 特点：与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法则为虚拟机所使用的Native方法服务 可能抛出的异常：与虚拟机栈一样，本地方法栈区域也乎抛出StackOverflowError和OutOfMemoryError异常。 Java堆(Java Heap) Java堆是垃圾收集器管理的主要区域（GC堆），可细分为：新生代，老年代，按空间可细分为：Eden空间，From Survivor空间，To Survivor空间 作用： Java Heap是被所有线程共享的一块区域，在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，让对象实例更好地分配内存。 垃圾回收机制(GC)：堆是垃圾收集器管理的主要区域，可以更好地回收内存。 存储内容： 存放对象实例，几乎所有的对象实例都在这里进行分配。堆可以处于物理上不连续的内存空间，只要逻辑上是连续的就可以。 值得注意的是：在JIT编译器等技术的发展下，所有对象都在堆上进行分配已变得不那么绝对。有些对象实例也可以分配在栈中。 可能出现的异常： 实现堆可以是固定大小的，也可以通过设置配置文件设置该为可扩展的。 如果堆上没有内存进行分配，并无法进行扩展时，将会抛出OutOfMemoryError异常。 方法区(Method Area) 作用：方法区和Java堆一样，是各个线程共享的内存区域。 意义：对运行时常量池、常量、静态变量等数据做出了规定。 存储内容：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 可能出现的异常：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池(Runtime Constant Pool) 作用用于存放编译期生成的各种字面量和符号的引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 特征运行时常量池对于Class文件常量池的另一个特征是具备动态性，在运行期间也可能将新的常量放入池中，例如String类的intern() 可能抛出的异常运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存(Direct Memory) 作用JDK1.4中新加入NIO类，引入一种基于通道与缓冲的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffeer对象作为这块内存的引用进行操作。（在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回复制数据） 可能抛出的异常服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常会忽略直接内存，使得内存区域总和大于物理内存限制(包括物理等和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。 HotSpot虚拟机对象对象创建 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 内存分配的两种方式： 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定 指针碰撞Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离 空闲列表Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding） HotSpot虚拟机的对象头包括两部分信息： Mark Word第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。 类型指针对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。 对象的访问定位 建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。 目前主流的访问方式有使用句柄和直接指针两种： 句柄访问 直接指针访问 对比优势： 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。Sun HotSpot虚拟机是使用第二种方式进行对象虚拟机访问的。 OutOfMemoryError异常 除了程序计数器，其他运行时区域都有可能抛出OutOfMemoryError异常 Java堆溢出 内存泄露查看泄露对象到GC Roots的引用链，定位泄露代码位置。 内存溢出如果不存在泄露，即内存中的对象确实都还必须活着，检查JVM堆参数（-Xmx与-Xms），调大参数，检查代码是否存在某些对象生命周期过长，持有状态过长的情况，减少程序运行期的内存消耗。 虚拟机栈、本地方法栈溢出HotSpot不区分虚拟机栈和本地方法栈，栈容量只能由-Xss参数设定。 StackOverFlow：线程申请的栈深度超过允许的最大深度 OutOfMemoryError： 虚拟机扩展时无法申请到足够的内存空间 StackOverFlow的情况：递归调用方法，定义大量的本地变量，增大此方法帧中本地变量表的长度。 OutOfMemoryError：多线程下的内存溢出，与栈空间是否足够大并不存在任何联系。为每个线程的栈分配的内存越大（参数-Xss），那么可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽，越容易内存溢出。在这种情况下，如果不能减少线程数目或者更换64位虚拟机时，减少最大堆和减少栈容量能够换区更多的线程。 方法区和运行时常量池溢出 运行时常量池String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用 方法区方法区用于存放Class的相关信息，如果运行时产生大量的类去填满方法区，就可能发生方法区的内存溢出。 例如主流框架Spring、Hibernate对大量的类进行增强时，利用CGLib字节码生成动态类；大量JSP或动态JSP(JSP第一次运行时需要编译为Java类）。 本机直接内存溢出Java虚拟机可以通过参数-XX:MaxDirectMemorySize设定本机直接内存可用大小，如果不指定，则默认与java堆内存大小相同。JDK中可以通过反射获取Unsafe类(Unsafe的getUnsafe()方法只有启动类加载器Bootstrap才能返回实例)直接操作本机直接内存。通过使用-XX:MaxDirectMemorySize=10M，限制最大可使用的本机直接内存大小为10MB。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Reading</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T-Bag]]></title>
    <url>%2F2018%2F10%2F04%2FT-Bag-Prelude%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer6"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/T-Bag.mp4"},"danmaku":{"id":"TBagPrelude","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM01-走近Java]]></title>
    <url>%2F2018%2F10%2F04%2FJVMpro01%2F</url>
    <content type="text"><![CDATA[第一章的内容大致翻阅了一下感觉还是挺多的，大致都是关于Java的特点、发展史、Java未来的走向以及阅读OpenJDK源码的指导。对于第一章的内容我也准备做一些总结，以备以后的扩充和温故。 Java的特性和优点 提升了开发效率 结构严谨，面向对象 摆脱硬件束缚，“一次编写，到处运行” 相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界问题(内存回收机制) 热点代码检测和运行时编译及优化，运行次数越多性能越好 完善的应用程序接口(第三方类库) Java的技术体系Sun公司所定义的Java技术体系包括以下几个组成部分： Jav程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式（面向对象的载体） Java API库（Java自带可调用的库） 来自商业机构和开源社区的第三方Java类库（封装好的库） JDK(Java Development Kit)：1+2+4，也就是支持Java开发的最小环境。JRE(Java Runtime Environment)：JavaSE(Java Standard Edition)的API+虚拟机。 Java技术体系模块图： 按照技术服务领域划分，Java技术体系可以分为4个平台： JavaCard：支持一些Java小程序运行在小内存设备上的平台，如智能卡 JavaME(Micro Edition)：支持Java运行在移动终端上的平台，对JavaAPI有所精简，并加入了针对移动端的支持 JavaSE(Standard Edition)：支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API。 JavaEE(Enterprise Edition)：支持使用多层架构的企业应用(如ERP、CRM应用)的Java平台，对JavaSE API做了大量的扩充并提供相关的部署支持 入门版(Card)👉阉割版(ME)👉标配(SE)👉Pro(EE) Java发展史 1991年，提出绿色项目（猜想可能是针对c/c++中的垃圾回收，内存处理之类的问题而提出的一个更友好的语言概念）; 创立oak（java语言的前身，为了解决家用电器的通信问题而诞生，没有理想市场，不久后将要失败）;设计出硬件原型；同时设计出注释器。 1992年，更名为java; Star-Seven Prototype(七星原型，度娘上查了好久没找到，有机会去翻墙再查吧。 猜想可能是当时那个版本的七大基本规范吧。。。先记下来); 1993年，TV Set-top Box ( 可能是在电视机顶盒 试用吧)；发布应用开发平台。。 1994年，LiveOak（可能是oak发展有一些起色的意思吧。英语不好真的很忧伤。）;发布Era浏览器；继而发布HotJava浏览器；设计出java编译器； 1995年，正式注册java,并相继获得Netscape,Oracle,Microsoft的支持，HotJava进一步发展。 1996年，java1.0发布。 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1997年，java1.1发布。 1997年9月，JavaDeveloperConnection社区成员超过十万 。 1998年2月，JDK1.1被下载超过2,000,000次 1998年，java1.2发布。 1998年12月8日，JAVA2企业平台J2EE发布。 1999年6月，SUN公司发布Java的三个版本：标准版、企业版和微型版（J2SE、J2EE、J2ME） 2000年，java1.3发布。 2002年，java1.4发布，自此Java的计算能力有了大幅提升。 2004年，java5.0发布，J2SE1.5发布，是Java语言的发展史上的又一里程碑事件。为了表示这个版本的重要性，J2SE1.5更名为J2SE5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字“2”：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。 2006年，java6.0发布，并半开源。 2010年，Oracle收购Sun公司，苹果不再支持java 2011年，java7.0发布。 2014年，java8.0发布。 Java虚拟机发展史 Sun Classic/Exact VM(初代)：世界上第一款商用Java虚拟机，Sun公司研发，主要特点：慢。 Sun HotSpot VM(新技术)：目前使用范围最广的虚拟机，是Sun从一家名为Longview Technologies公司收购来的。主要特点：热点探测技术。 Sun Mobile-Embedded VM/Meta-Circular VM(探索)：面对移动嵌入式市场的探索 BEA JRockit /IBM J9 VM(其它公司)：当时号称”世界上最快的Java虚拟机” Azul VM/BEA Liquid VM(特定硬件)：高性能Java的武器，特定硬件可以最大限度地发挥硬件的能力，提升Java程序的执行能力。 Apache Harmony/Google Android Dalvik VM(高速发展)：安卓虚拟机。是Android平台的核心组成部分之一。 Microsoft JVM(彩蛋)：2333 Java的未来 模块化：说起来也就是解除功能模块和功能模块之间的耦合，降低系统维护消耗。(书上也没仔细说，大家看着标题脑补一下也就知道是干嘛的) 混合语言：对系统来说是好事(因为不同语言有不同语言的特点 也就是擅长的地方)，但是对于Java程序员的要求也会因此而提高。 多核并行：顺应发展 丰富语法：更新JDK版本 64位虚拟机：现在64位虚拟机速度没有32位快，主要是Java EE对64位虚拟机的要求比较急迫。 自己编译JDK想要一探JDK内部的实现机制，最便捷的路径之一就是自己编译一套JDK，通过阅读和跟踪调试JDK源码去了解Java技术体系的原理，虽然门槛会高一点，但肯定会比阅读各种书籍、文章更加贴近本质。另外，JDK中很多底层方法都是本地化的，需要跟踪这些方法的运作或对JDK进行Hack的时候，都需要自己编译一套JDK。 OpenJDK源码结构图： 123456789101112131415161718192021222324252627282930313233343536373839├─agent Serviceability Agent的客户端实现 ├─make 用来build出HotSpot的各种配置文件 ├─src HotSpot VM的源代码 │ ├─cpu CPU相关代码（汇编器、模板解释器、ad文件、部分runtime函数在这里实现） │ ├─os 操作系相关代码 │ ├─os_cpu 操作系统+CPU的组合相关的代码 │ └─share 平台无关的共通代码 │ ├─tools 工具 │ │ ├─hsdis 反汇编插件 │ │ ├─IdealGraphVisualizer 将server编译器的中间代码可视化的工具 │ │ ├─launcher 启动程序“Java” │ │ ├─LogCompilation 将-XX:+LogCompilation输出的日志（hotspot.log）整理成更容易阅读的格式的工具 │ │ └─ProjectCreator 生成Visual Studio的project文件的工具 │ └─vm HotSpot VM的核心代码 │ ├─adlc 平台描述文件（上面的cpu或os_cpu里的*.ad文件）的编译器 │ ├─asm 汇编器接口 │ ├─c1 client编译器（又称“C1”） │ ├─ci 动态编译器的公共服务/从动态编译器到VM的接口 │ ├─classfile 类文件的处理（包括类加载和系统符号表等） │ ├─code 动态生成的代码的管理 │ ├─compiler 从VM调用动态编译器的接口 │ ├─gc_implementation GC的实现 │ │ ├─concurrentMarkSweep Concurrent Mark Sweep GC的实现 │ │ ├─g1 Garbage-First GC的实现（不使用老的分代式GC框架） │ │ ├─parallelScavenge ParallelScavenge GC的实现（server VM默认，不使用老的分代式GC框架） │ │ ├─parNew ParNew GC的实现 │ │ └─shared GC的共通实现 │ ├─gc_interface GC的接口 │ ├─interpreter 解释器，包括“模板解释器”（官方版在用）和“C++解释器”（官方版不在用） │ ├─libadt 一些抽象数据结构 │ ├─memory 内存管理相关（老的分代式GC框架也在这里） │ ├─oops HotSpot VM的对象系统的实现 │ ├─opto server编译器（又称“C2”或“Opto”） │ ├─prims HotSpot VM的对外接口，包括部分标准库的native部分和JVMTI实现 │ ├─runtime 运行时支持库（包括线程管理、编译器调度、锁、反射等） │ ├─services 主要是用来支持JMX之类的管理功能的接口 │ ├─shark 基于LLVM的JIT编译器（官方版里没有使用） │ └─utilities 一些基本的工具类 └─test 单元测试]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Reading</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何编写Alfred Workflow]]></title>
    <url>%2F2018%2F09%2F21%2FAlfredKnowledgeBase%2F</url>
    <content type="text"><![CDATA[语言基础Alfred官方并没有给出详细的Alfred Workflow撰写教程，原因是写一个Workflow的实际门槛是很低的。他们大部分是使用一门了解的语言来书写的。在Alfred也罗列了这些语言： 包括： bash, zsh, PHP, Ruby, Python, Perl, AppleScript, JavaScript 开发者只需要会使用上面任意的语言，就可以开始编写自己的Alfred Workflow了。 如何使用Alfred？Alfred有个很好的地方，就是能在Alfred中看到你所使用的Alfred的具体实现，workflow也都是开源的。大部分workflow都可以直接在Alfred的workflows选项卡下看到，部分workflow可能需要调用一些脚本文件，你也可以进入对应的workflow文件夹下打开具体的脚本文件（可以通过workflows👉Show in Finder打开对应的workflow文件夹） Alfred workflow有几个关键组成部分，包括Triggers、Inputs、Actions、Outputs。 Triggers用于设置快捷键，并不是必备的，因为Option+Space快捷键就可以快捷打开Alfred输入框 Inputs定义了在Alfred输入框中输入对应的keyword调用相关的操作 Action就是keyword调用的操作 Outputs一般用于显示操作的结果，提示操作成功与否，以Post Notification较为常见，通过Mac的notification center提示。 🤨Alfred使用手册🤨👉Alfred2.5.1使用全攻略👉Alfred：基础功能及设置👉编写 Alfred 使用的 Workflow]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
        <tag>Workflow</tag>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred的OSS图床Workflow(python)]]></title>
    <url>%2F2018%2F09%2F20%2FAlfredWorkflowOSS%2F</url>
    <content type="text"><![CDATA[前言什么是Alfred？Alfred依靠它强大的工作流机制，可以极大地提高Mac系统的工作效率。 作为 Mac 上最强大的效率工具，Alfred 在 Spotlight（MacOS X 自带的搜索和快速启动引擎）的基础上优化了快速启动与搜索的功能，还引入了 Workflows 等强大的扩展功能，使之成为了一个拥有无限自动化潜力的「工具平台」软件，可以用它来实现近乎一切有关自动的想法。 为什么要使用这个Workflow？因为在编写个人博客，每次插入图片的时候都需要将图片上传到OSS图床，具体需要以下步骤： 截图 保存图片到桌面 打开浏览器 登陆阿里云 打开OSS控制台 上传图片 等待并获取url 回到markdown编辑器粘贴到![]()中 而现在使用这款插件只需要三步： 截图 Toggle Alfred 并键入：OSS 回到markdown编辑器粘贴 好吧，其实主要还是因为穷QAQ，因为不需要折腾的iPic需要订阅，每年¥68。 安装及配置环境 一台MacOS的电脑 Alfred 阿里云OSS python3环境 python3依赖oss2和pyobjc包 👉python3安装教程 安装依赖打开命令行输入：1pip install oss2 1pip install pyobjc 脚本需要修改的参数修改位置：右键OSS - 选择Open in Finder - 修改其中的clipboard_data.py文件 修改下面这三行的内容： 123access_key_id = &apos;&lt;yourAccessKeyId&gt;&apos;access_key_secret = &apos;&lt;yourAccessKeySecret&gt;&apos;bucket_name = &apos;&lt;yourBucketName&gt;&apos; 1bucket = oss2.Bucket(auth, &apos;http://oss-cn-hangzhou.aliyuncs.com&apos;, bucket_name) 👉如何获取AccessKey ID和Secret 如何使用复制一张图片，调用alfred，输入oss命令稍等一小会儿，会显示url和md两种返回格式，点击url或者md便可以获得对应地址在剪切板中，粘贴，所见即所得 👉GIthub地址 最后，感谢 @CQhui 写的AlfredWorkflow！]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Alfred</tag>
        <tag>tech</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识遗传算法]]></title>
    <url>%2F2018%2F09%2F18%2FGeneticAlgorithm01%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Videos/AI%20learns%20to%20play%20Google%20Chrome%20Dinosaur%20Game%20--%20Can%20you%20beat%20it.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() Github源码链接 什么是遗传算法？遗传算法的由来 Species to survive, is not the most strong, is not the most intelligent， but those who make a rapid response to change. 物尽天择，适者生存。 查尔斯达尔文在一百多年前提出的“生物进化论”，他证明生物的起源是在遗传、变异、生存斗争和自然选择中，从简单到复杂、从低等到高等不断地发展变化而来的。达尔文的进化论给美国的科学家霍兰德留下了深刻的印象，他从计算机角度思考了这个问题，也就是遗传算法的由来。遗传算法也便继承了“进化论”的思想，将需要解决的问题模拟成一个生物进化的过程，通过复制、交叉、突变等操作产生下一代的解，并逐步淘汰适应度(Fitness)低的解，经过N代自然选择后，会进化出适应度函数值很高的个体。 定义：&emsp;&emsp;遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。 相关术语 table th:nth-of-type(1){ width: 25%; } table th:nth-of-type(2){ width: 75%; } 相关术语 解释 基因型(genotype) 性状染色体的内部表现 表现型(phenotype) 染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现 进化(evolution) 种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的 适应度(fitness) 度量某个物种对于生存环境的适应程度 选择(selection) 以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程 复制(reproduction) 细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。 交叉(crossover) 两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交 变异(mutation) 复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状 编码(coding) DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射 解码(decoding) 基因型到表现型的映射 个体（individual） 指染色体带有特征的实体 种群（population） 个体的集合，该集合内个体数称为种群的大小 遗传算法的应用遗传算法的有趣应用很多，诸如寻路问题，8数码问题，囚犯困境，动作控制，找圆心问题（在一个不规则的多边形中，寻找一个包含在该多边形内的最大圆圈的圆心），TSP问题，生产调度，模式识别，神经网络，自适应控制等。 一个简单的例子求解函数 f(x) = x + 10*sin(5*x) + 7*cos(4*x) 在区间[0,9]的最大值 那么如何通过遗传算法找到这个函数的最大值呢？ 事实上，不管一个函数的形状多么奇怪，遗传算法都能在很短的时间内找到它在一个区间内的(近似)最大值。 👉具体分析 遗传算法思想GA的组成： 编码(产生初始种群)👉创造染色体 个体👉种群 适应度函数 遗传算子(选择、交叉、变异) 运行参数 种群大小 染色体长度 最大迭代次数 交叉概率 变异概率 是否选择精英操作 GA算法特点遗传算法的优点 群体搜索，易于并行化处理； 不是盲目穷举，而是启发式搜索； 适应度函数不受连续、可微等条件的约束，适用范围很广。 容易实现。一旦有了一个遗传算法的程序，如果想解决一个新的问题，只需针对新的问题重新进行基因编码就行；如果编码方法也相同，那只需要改变一下适应度函数就可以了。 遗传算法的缺点 全局搜索能力不强,很容易陷入局部最优解跳不出来；(可结合SA进行改进,因为SA在理率上是100%得到全局最优的,但搜索代价高) 将遗传算法用于解决各种实际问题后，人们发现遣传算法也会由于各种原因过早向目标函数的局部最优解收敛，从而很难找到全局最优解。其中有些是由于目标函数的特性造成的，例如函数具有欺骗性，不满足构造模块假说等等；另外一些则是由于算法设计不当。为此，不断有人对遗传算法提出各种各样的改进方案。例如：针对原先的定长二进制编码方案；提出了动态编码、实数编码等改进方案；针对按比例的选择机制，提出了竞争选择、按续挑选等改进方案；针对原先的一点交算子，提出了两点交、多点交、均匀交等算子；针对原先遗传算法各控制参数在进化过程中不变的情况，提出了退化遗传算法、自适应遗传算法等。另外，针对不同问题还出现了分布式遗传算法、并行遗传算法等等。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云产品]]></title>
    <url>%2F2018%2F09%2F16%2FAbout-AliCloud%2F</url>
    <content type="text"><![CDATA[产品及功能ESC(Elastic Compute Service)以虚拟机的方式将一台物理机分成多台云服务器，提供可伸缩的计算服务。 衍生产品： 阿里云从云服务器ESC衍生出来很多云服务器系列，例如适用于初级用户的轻量应用服务器，还有 为了迎合各种高性能场景的云服务器，诸如GPU云服务器、FPGA云服务器等，总之都是云服务器，是企业上云的基本款。 关于轻量应用服务器： 精简了一些 ECS 的功能，比如说安骑士。把安全组的操作也做了适当减法更适合用户操作。 轻量应用服务器有轻量两个字，意味着其无法持续进行高负载运行（即 CPU 长时间高负载占用），如果我们要利用 轻量应用服务器 来进行持续的渲染、转码、机器学习等持续高负载操作那么就不可以了，也不支持 Nvme 这样的超高性能的 SSD，这对于读写敏感的操作就不好了。 阿里云的“云翼计划”的学生服务器就是轻量应用服务器。 RDS(Relational Database Service)通过云服务的方式让关系型数据库管理、操作和扩展变得更加简单。 OSS(Open Store Service)对任意大小数据对象提供高可用、高可靠的海量存储服务。 相关文章： 阿里云对象存储OSS SLB(Server Load Balance)基于LVS和Tengine实现的4层和7层负载均衡，有动态扩容。 OCS(Open Cache Service)基于内部Tair，增加一层Proxy，支持海量小数据的高速访问。 OTS(Open Table Service)海量(结构化)数据存储和实时查询服务 CDN(Content Delevery Network)通过覆盖全网的缓存服务以及负载均衡等技术将用户请求定向到最合适的区域，提高用户服务的响应速度及网站服务能力。 OAS(Open Archive Service)离线归档，冷数据备份，类似Amazon Glacier ODPS(Open Data Processing Service)海量数据处理和分析平台。 SLS(Simple Log Service)解决异构、分布式系统中日志实时收集、存储与查询的基础服务]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[血小板まとめ]]></title>
    <url>%2F2018%2F09%2F14%2FHataraku-Cute%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/%E3%80%8C%E3%81%8A%E7%96%B2%E3%82%8C%E6%A7%98%E3%81%A6%E3%82%99%E3%81%99%EF%BC%81%E3%80%8D%E8%A1%80%E5%B0%8F%E6%9D%BF%E3%81%AE%E7%AC%91%E9%A1%94%E3%81%8B%E3%82%99%E5%8F%AF%E6%84%9B%E3%81%99%E3%81%8D%E3%82%99%E3%82%8B%E3%80%90%E3%81%AF%E3%81%9F%E3%82%89%E3%81%8F%E7%B4%B0%E8%83%9E%E3%80%91Hataraku%20Saibou%20Cute%20Moments.mp4"},"danmaku":{"id":"Platelet","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Anime</tag>
        <tag>Cute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云对象存储OSS]]></title>
    <url>%2F2018%2F09%2F14%2FAliCloudOSS%2F</url>
    <content type="text"><![CDATA[OSS阿里云对象存储服务（Object Storage Service，简称 OSS），提供海量、安全、低成本、高可靠的云存储服务。其性质相当于阿里云提供的网盘服务，支持最基本的上传和下载，支持外链。OSS的存储空间以外网流出流量都是要收费的 CDN（CDN加速）全称：Content Delivery Network，内容分发网络是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络，替代传统以WEB Server为中心的数据传输模式。相当于访问就近的服务器点就个人博客而言，不需要CDN加速 存储量存储量指占用的存储空间容量 流量流量指您使用的网络带宽流量累计值，包括外网流出流量、内网流出流量、外网流入流量、内网流入流量、CDN回源流出流量、跨区域复制流量： 外网流出流量(收费): 通过互联网从 OSS 下载数据到本地端所产生的下行流量 内网流出流量(免费): 通过阿里云内网从 OSS 下载数据到 ECS 服务器所产生的下行流量 外网流入流量(免费) : 通过互联网从本地端上传数据到 OSS 所产生的上行流量 内网流入流量(免费) : 通过阿里云内网从 ECS 服务器上传数据到 OSS 所产生的上行流量 CDN回源流出流量(收费) : 通过 CDN 服务层下载 OSS 的数据所产生的回源下行流量 跨区域复制流量(收费) : 使用跨区域复制功能将源 Bucket 的数据同步复制到目标 Bucket 时所产生的流出流量 请求次数调用 OSS OPEN API 的请求次数。比如: 你的一篇博客中有6张图片(都是使用OSS存储做外链),那么当你打开这篇博客时就产生了6次请求。另外: OSS 控制台操作也是通过 OSS OPEN API 调用实现的，因此使用 OSS 控制台也会产生请求次数。 收费模式： 按量付费： 存储费用：存储单价 x 存储量 流量费用：外网流出流量忙时单价 x 流量 请求费用：Put请求 + Get请求汇总的费用 包年包月： 存储费用：存储包平均每月的费用 流量费用：外网流出流量包平均每月的费用 请求费用：Put请求 + Get请求汇总的费用 OSS+CDN组合： 存储费用：存储包平均每月的费用 流量费用：CDN公网流量费用 + CDN回源流量费用 请求费用：CDN回源请求费用 总结：个人博客建议按流量计费]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nike-Dream Crazy]]></title>
    <url>%2F2018%2F09%2F14%2FNike-Dream-Crazy%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"video":{"url":"http://ts1989ed.oss-cn-shenzhen.aliyuncs.com/Nike%20-%20Dream%20Crazy.mp4"},"danmaku":{"id":"NikeDreamCrazy","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>广告</tag>
        <tag>Inspirational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶]]></title>
    <url>%2F2018%2F09%2F04%2FAdvancedOperationInHexo%2F</url>
    <content type="text"><![CDATA[目录结构12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 为什么在custom.styl修改CSS文件?👉Stylus让CSS也能编程 修改文章页宽打开\themes\next\source\css\ _variables\base.styl文件，找到以下字段并修改为合适的宽度: 1content-desktop-large = 1000px 修改小型代码块颜色修改\themes\next\source\css\ _variables\base.styl文件，修改代码加入自定义颜色： 123456789$black-deep = #222$red = #ff2a2a$blue-bright = #87daff$blue = #0684bd$blue-deep = #262a30$orange = #fc6423// 下面是我自定义的颜色$my-code-foreground = #dd0055 // 用``围出的代码块字体颜色$my-code-background = #eee // 用``围出的代码块背景颜色 修改$code-background和$code-foreground的值 123456// Code &amp; Code Blocks // 用``围出的代码块 // -------------------------------------------------- $code-font-family = $font-family-monospace $code-font-size = 15px $code-background = $my-code-background $code-foreground = $my-code-foreground $code-border-radius = 4px 添加文章结束标记同样在themes/next/layout/_macro/post.swig 中，在 wechat-subscriber.swig之前添加如下代码： 1&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt; 把侧边栏头像变成圆形，并且鼠标停留在上面发生旋转效果修改themes\next\source\css\_common\components\sidebar\sidebar-author.styl： 1234567891011121314151617181920212223242526272829.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: site-author-image-border-color; /* start*/ border-radius: 50% webkit-transition: 1.4s all; moz-transition: 1.4s all; ms-transition: 1.4s all; transition: 1.4s all; /* end */&#125;/* start */.site-author-image:hover &#123; background-color: #55DAE1; webkit-transform: rotate(360deg) scale(1.1); moz-transform: rotate(360deg) scale(1.1); ms-transform: rotate(360deg) scale(1.1); transform: rotate(360deg) scale(1.1);&#125;/* end */ 修改链接文字样式打开themes\next\source\css\_common\components\post\post.styl添加以下代码，给链接添加颜色： 12345678.post-body p a&#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #ff106c; text-decoration: underline; &#125;&#125; 为next主题的主页文章添加阴影效果打开themes/next/source/css/_custom/custom.styl文件添加： 1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 为next主题添加nest背景特效背景几何线条是采用的nest效果，一个基于html5 canvas绘制的网页背景效果，非常赞！来自github的开源项目canvas-nest 特性 不依赖任何框架或者内库，比如不依赖 非常小，只有1.66kb 非常容易实现，配置简单，即使不是web的开发者，也能简单搞定 配置选项 color: 线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B)，注意用,分割 opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 不足：CPU占用过高 修改_layout.swig打开next/layout/_layout.swig在&lt;/body&gt;之前添加如下代码 可参考官方文档：Canvas-Nest 123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 修改主题配置文件打开/next/_config.yml，添加如下代码 1234567# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 运行hexo clean 和 hero g -d 之后就可以在网页上看到效果了。 隐藏网页底部powered by hexo/强力驱动打开hexo/themes/next/layout/_partials/footer.swig 找到下面这段代码，用第一行和最后一行注释掉即可 123456789101112131415&lt;!--&lt;div class="powered-by"&gt;&#123;# #&#125;&#123;&#123; __('footer.powered', '') &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; &lt;/div&gt;--&gt; 侧栏加入已运行时间themes/next/layout/_custom中添加sidebar.swig文件: 1234567891011121314151617181920212223242526&lt;div id="days"&gt;&lt;/div&gt; &lt;script&gt; function show_date_time()&#123; window.setTimeout("show_date_time()", 1000); BirthDay=new Date("01/10/2017 12:34:56"); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"; &#125;function setzero(i)&#123; if (i&lt;10) &#123;i="0" + i&#125;; return i;&#125;show_date_time();&lt;/script&gt; 在themes/next/layout/_macro/sidebar.swig中的&lt;/section&gt;之前添加: 1&#123;% include &apos;../_custom/sidebar.swig&apos; %&#125; 设置时间样式： 1234567// 自定义的侧栏时间样式#days &#123; display: block; color: #fffa74; font-size: 14px; margin-top: 15px;&#125; 更改tagcloud为彩色themes/next/layout/page.swig找到tagcloud并替换: 1&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125; 设置动态titlethemes/next/source/js/src下创建dytitle.js： 12345678910111213141516var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="shortcut icon"]').attr('href', "/TEP.png"); document.title = 'w(ﾟДﾟ)w 出BUG啦！！！！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="shortcut icon"]').attr('href', "/favicon.png"); document.title = '♪(^∇^*)又好了。。。 ' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125;&#125;); 修改themes/next/layout/layout.swing,在 &lt;/body&gt; 之前添加: 1&lt;script type="text/javascript" src="/js/src/dytitle.js"&gt;&lt;/script&gt; 修改文章底部带#的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 文字样式先在themes/next/source/css/_custom/custom.styl中添加以下样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221// 下载样式a#download &#123;display: inline-block;padding: 0 10px;color: #000;background: transparent;border: 2px solid #000;border-radius: 2px;transition: all .5s ease;font-weight: bold;&amp;:hover &#123;background: #000;color: #fff;&#125;&#125;/ /颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #f0ad4e;&#125;// 颜色块-绿span#inline-green &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #5cb85c;&#125;// 颜色块-蓝span#inline-blue &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #2780e3;&#125;// 颜色块-紫span#inline-purple &#123;display:inline;padding:.2em .6em .3em;font-size:80%;font-weight:bold;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0;background-color: #9954bb;&#125;// 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;// 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;// 左侧边框绿色块级p#div-border-left-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #5cb85c;&#125;// 左侧边框蓝色块级p#div-border-left-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #2780e3;&#125;// 左侧边框紫色块级p#div-border-left-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #9954bb;&#125;// 右侧边框红色块级p#div-border-right-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #df3e3e;&#125;// 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;// 右侧边框绿色块级p#div-border-right-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #5cb85c;&#125;// 右侧边框蓝色块级p#div-border-right-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #2780e3;&#125;// 右侧边框紫色块级p#div-border-right-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #9954bb;&#125;// 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;// 上侧边框黄色p#div-border-top-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #f0ad4e;&#125;// 上侧边框绿色p#div-border-top-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #5cb85c;&#125;// 上侧边框蓝色p#div-border-top-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#125;// 上侧边框紫色p#div-border-top-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#125; 用法如下： 12&lt;span id=&quot;inline-blue&quot;&gt;站点配置文件&lt;/span&gt;， &lt;span id=&quot;inline-purple&quot;&gt;主题配置文件&lt;/span&gt; 站点配置文件，主题配置文件 12&lt;p id="div-border-left-red"&gt;左边红色&lt;/p&gt;&lt;p id="div-border-top-blue"&gt;上边蓝色&lt;/p&gt; 左边红色上边蓝色 在文档中增加图标采用的是Font Awesome的图标。 给文档加密打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在开头的四个meta之后插入以下代码：1234567891011121314&lt;script&gt; (function () &#123; if ('&#123;&#123; page.password &#125;&#125;') &#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;') &#123; alert('密码错误！'); if (history.length === 1) &#123; location.replace("http://xxxxxxx.xxx"); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在MD文章头文件中加入 password: password 侧边栏推荐阅读打开主题配置文件修改成这样就行了（links里面写你想要推荐的链接）：1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 新增评论系统去除评论系统下方的powered by valine打开/next/layout/_third-party/comments/valine.swig文件，123456789101112131415161718new Valine(&#123; el: '#comments' , verify: &#123;&#123; theme.valine.verify &#125;&#125;, notify: &#123;&#123; theme.valine.notify &#125;&#125;, appId: '&#123;&#123; theme.valine.appid &#125;&#125;', appKey: '&#123;&#123; theme.valine.appkey &#125;&#125;', placeholder: '&#123;&#123; theme.valine.placeholder &#125;&#125;', avatar:'&#123;&#123; theme.valine.avatar &#125;&#125;', guest_info:guest, pageSize:'&#123;&#123; theme.valine.pageSize &#125;&#125;' || 10,&#125;);//新增以下代码即可，可以移除.info下所有子节点。var infoEle = document.querySelector('#comments .info');if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123; infoEle.childNodes.forEach(function(item) &#123; item.parentNode.removeChild(item); &#125;);&#125;]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手和四次挥手]]></title>
    <url>%2F2018%2F08%2F07%2FTCPShakeandWave%2F</url>
    <content type="text"><![CDATA[TCP三次握手建立连接 第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 通俗一点来讲，就是 主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。 为什么要三次握手？ 在谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 在谢希仁著《计算机网络》书中同时举了一个例子，如下： “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 所以三次握手是为了防止服务器端一直等待而浪费资源。 TCP四次挥手 当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次挥手？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方） FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方） CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方） LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方） TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方） CLOSED: 表示连接中断。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Communication Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通信协议 —— TCP UDP HTTP]]></title>
    <url>%2F2018%2F08%2F07%2FTCP-UDP-HTTP%2F</url>
    <content type="text"><![CDATA[什么是Http、Socket、TCP/IP？HTTP ( HyperText Transfer Protocal ) ，即：超文本传输协议，从1990年开始就在WWW上广泛应用，是当今在WWW上应用最多的协议，Http是应用层协议，当浏览网页的时候，浏览爱和Web服务器之间就会通过HTTP在Internet上进行数据的发送和接收，Http是一个基于请求/响应模式的、无状态的协议。即我们通常所说的Request/Response。HTTP是利用TCP在两台电脑（通常是Web服务器和客户端）之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。Socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 TCP/IP 模型在原有OSI模型的基础上进行了简化，由原先的八层（应用层、表示层、会话层、传输层、网络层、数据链路层、物理层）变成了四层（应用层、传输层、网际层IP、网络接口层） TCP HTTP UDP SOCKET四者的关系？ IP是网络层协议，相当于高速公路；TCP和UDP是传输层协议，相当于卡车；HTTP是应用层的协议，相当于货物；SOCKET是TCP/IP网络的API，相当于码头和车站 TCP/IP是一个协议组，可以分为四个层次：网络接口层、网络层、传输层、和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议和UDP协议。 在应用层中有FTP、HTTP、TELNET、SMTP、DNS等协议。 HTTP是从Web服务器传输超文本到本地浏览器的传送协议。 TCP和UDP的区别TCP（Transmission Control Protocol）传输控制协议：类似打电话 面向连接、传输可靠、有序、传输大量数据、速度慢、对系统资源要求多、程序结构复杂 每一条TCP连接只能是点到点的 TCP首部开销20字节 UDP（User Data Protocol）用户数据报协议：类似发短信 面向非连接、传输不可靠、无序、传输少量数据、速度快、对系统资源要求少、程序结构简单 UDP支持一对一，一对多，多对一和多对多的交互通信 UDP首部开销小，只有8个字节]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Communication Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识汇总]]></title>
    <url>%2F2018%2F01%2F14%2FFirstInterviewForJava%2F</url>
    <content type="text"><![CDATA[定义部分Q1: 什么是面向对象编程思想？ 面向对象是相对于面向过程的。面向对象不用关心处理问题的细节，只需要关心结果。 面向对象有三大特性：封装、继承和多态。封装的目的是复用；继承目的是共用；多态目的是多种实现。 Q2: Servlet的概念及功能？ Servlet是JavaEE规范中的Web开发组件 Servlet运行在服务器端，需要Servlet容器的支持，例如Tomcat 可以通过浏览器访问Servlet，Servlet可以生成动态页面返回给浏览器 Servlet也是一段代码，是一个Java类，这个Java类需要遵守一定的编写规范 Q3: JSP(Java Server Pages)概念？ JSP是JavaEE规范中的Web组件，用来编写动态页面 JSP运行在服务器端，本质是Servlet JSP文件以.jsp为后缀，在Eclipse的工程目录中存在WebContent目录下 JSP文件可以直接在浏览器中访问 JSP文件中的内容就是 HTML+Java代码，静态部分使用HTML和文本即可，动态部分使用Java代码 Q4: Servlet与JSP的作用？ JSP往往用来生成动态页面，而Servlet虽然可以生成动态页面却过于麻烦，往往用来接收JSP的请求，处理请求，然后跳转到不同JSP页面进行结果显示； Servlet和JSP之间的跳转有两种方式，分别是响应重定向和请求转发； 响应重定向相当于客户端重新发出请求，之前的请求不再保存；请求转发是把当前请求转发到下一个资源；比较常用的是请求转发； 请求参数是用户提交请求时，自动封装到请求对象中的一些输入信息，都是String类型； 请求属性可以是任意类型的对象，可以用setAttribute方法将对象作为属性存储到请求对象中； Q5: JDBC的概念？ JDBC是指Java数据库连接，是一种标准Java应用编程接口，用来连接Java编程语言和广泛的数据库 JDBC的本质是一种规范，它提供了一套完整的借口，允许便捷式访问到底层数据库，因此Java编写不同类型的可执行文件都可以使用JDBC驱动程序来访问数据库。 Q6: SSM框架的基本概念 SSM框架，是Spring + SpringMVC + MyBatis的缩写，是目前主流的Java EE框架，适用于搭建各种大型企业级应用系统。 SSM框架将系统划分为表现层，controller层，service层，DAO层 Spring实现业务对象管理，Mybatis座位数据对象的持久化引擎，Spring MVC负责请求的转发和视图管理 Q7: Spring的功能： Spring 容器提供了IOC机制，可以创建对象以及管理对象之间的调用关系，避免了硬编码造成的程序耦合 提供了AOP（面向切面编程方式）功能，可以实现很多特定功能 声明式事务控制处理 对JDBC进行了轻量级的封装，可以更加灵活的去操作数据库 提供了MVC设计模式的解决方案 提供了文件上传、定时器等常用工具类 对于其他优秀框架的支持（如：Struts、Hibernate、MyBatis、Quartz等） Spring的IoC容器是Spring的核心，Spring AOP是Spring框架的重要组成部分。 Q8: IoC (Inversion of Control) 控制反转？ 在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），依赖注入和控制反转是同一个概念。 IoC是解耦,提供一种构造对象的方式，使得一种功能能有多种实现，且不构成依赖。spring 的IOC的缺点：占用内存多、构造对象慢、启动慢。 控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。所以IoC也叫依赖注入（Dependency Injection）。实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 Q9: AOP和OOP的联系和区别？ OOP的封装要求将功能分散到不同的对象中去，在软件设计中称为指责分配。让不同的类实现不同的方法，这样代码就分散到一个个类中去了，降低了代码的复杂程度，使类可重用。面向对象设计让类与类之间无法联系，而不能将这些重复的代码统一起来。因此分散代码的同时，也增加了代码的重复性。也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。从技术上来说，AOP基本上是通过代理机制实现的。AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。 OOP (Object Oriented Programming) 侧重于静态，名词，状态，组织，数据，载体是空间 AOP (Aspect Oriented Programming) 侧重于动态，动词，行为，调用，算法，载体是时间 Q10: MVC (Model-View-Controller) 框架？ MVC是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 MVC虽然分为三部分，但是MVC跟经典三层没有任何关系，它只存在于Web层，将Web层的数据、业务处理和显示分隔开。 model是应用程序中用于处理数据逻辑的部分。通常模型对象负责在数据库中存取数据。 view是应用程序中处理数据显示的部分。通常视图是依据数据模型创建的。 controller是应用程序中处理数据交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送。 对于开发存在大量用户界面，并且业务逻辑复杂的大型应用程序，MVC将会使你的软件在健壮性、代码重用和结构方面上一个新的台阶。尽管在最初构建MVC框架时会花费一定的工作量，但从长远角度看，它会大大提高后期软件开发的效率。 MVC是用来分割页面和数据库访问的框架，降低两者的耦合度，同时通过Controller的控制，使系统更加的灵活，代码更加健壮，复用性更强。 Q11: 为什么使用MyBatis？ 在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 Java相关小知识点01 run是线程执行的方法 start是启动线程对象，使之从新建状态进入就绪状态 sleep让线程睡眠，在此期间线程不消耗CPU资源 suspend使线程挂起，暂停执行，如果想要恢复线程，必须由其它线程调用resume方法]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库整理]]></title>
    <url>%2F2018%2F01%2F02%2FSQLfirstview%2F</url>
    <content type="text"><![CDATA[关于主键和外键： 简而言之，SQL的主键和外键就是起约束作用。 关系型数据库中一条记录中有若干个属性，若其中某一个属性组（注意是组）能唯一标识一条记录，该属性就可以成为一个主键。 成绩表中单一一个属性无法唯一标识一条记录，学号和课程编号的组合才可以唯一标识一条记录，所以学号和课程编号的属性组是一个主键。 成绩表中的学号不是成绩表中的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键；同理，成绩表中的课程号是课程表的外键。 定义： 123主键：唯一标识一条记录，不能有重复，不允许为空。外键：表的外键是另一表的主键，外键是可以有重复的，可以是空值。索引：该字段没有重复值，但可以有一个空值。 作用： 123主键：用来保证数据完整性外键：用来和其他表建立联系用索引：用来提高查询排序的速度 个数： 123主键：主键只能有一个。外键：一个表可以有多个外键。索引：一个表可以有多个唯一索引。 常用数据库查询操作数据库查询 数据库操作的原理就是将需求翻译成数据库语言 简单的单表查询操作查询“数据库原理”课程的学分； 12SELECT cname，credit FROM course WHERE cname = ‘数据库原理’从course表中取出cname和credit数据，条件是cname为数据库原理 查询选修了课程编号为“C01”的学生的学号和成绩，并将成绩按降序输出； 12SELECT sno，grade FROM sc WHERE cno = ‘C01’ ORDER BY grade DESC；从sc表中选出sno和grade数据，条件是cno是C01，按grade降序输出 查询学号为“31401”的学生选修的课程编号和成绩； 12SELECT cno，grade FROM sc WHERE sno = ‘31401’从sc表中选出cno和grade两个数据，条件是sno为31401 查询选修了课程编号为“C01”且成绩高于85分的学生的学号和成绩； 12SELECT sno, grade FROM sc WHERE cno = &apos;C01&apos; AND grade &gt; 85;从sc表中查询sno和grade，条件是cno为C01以及grade大于85分 简单的多表的连接查询 由于学号和成绩分别在student和sc表中，所以这是多表查询，多表查询注意隐含条件的表达 查询选修了课程编号为“C01”且成绩高于85分的学生的学号、姓名和成绩； 12SELECT sc.sno, sname, grade FROM student, sc WHERE student.sno = sc.sno AND cno = &apos;C01&apos; AND grade &gt;85;从student和sc表中选取学号、姓名和成绩，条件是课程编号C01、成绩&gt;85、并且【学生编号相同】 查询所有学生的学号、姓名、选修的课程名称和成绩； 12SELECT sc.sno, sname, cname, grade FROM student, sc, course WHERE sc.sno = student.sno AND sc.cno = course.cno;从student、course和sc表中查询学号、姓名、课程名和成绩，条件是三个表中的学号均相同 复杂的查询操作 GROUP BY用于合计函数，根据一个或多个列对结果集进行分组，比如这题想要得到的是 学生 的 课程总和 ，所以GROUP BY学生，合计课程号cno 查询至少选了三门课程的学生的学号和姓名； 12345SELECT sc.sno, sname FROM sc, student WHERE sc.sno = student.sno GROUP BY sc.sno HAVING COUNT(sc.cno)&gt;=3从sc和student表中查询，条件是学号相同，并且统计选课&gt;=3 GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组 查询所有学生的学号和他选修课程的最高成绩，要求他的选修课程中没有成绩为空的； 12SELECT sno, max(grade) FROM sc GROUP BY sno HAVING MIN(grade) &gt; 0;这里调用一个max，并且选课成绩不为空仍然用group by和having min 带有IN、比较符的嵌套查询查询修了数据库原理的学生的学号和姓名; 123456SELECT sc.sno, sname FROM student, scWHERE sc.sno = student.sno AND sc.cno IN (SELECT cno FROM course WHERE cname = &apos;数据库原理&apos;)；从student和sc中查询学号和姓名，条件是学号相同，这里IN相当于等号【在course表中数据库对应的cno】 inner join表示输出前后两个表的共同部分on【共同的志向条件】 查询没有选修数据库原理的学生的学号和姓名； 12345678SELECT sno, sname FROM studentWHERE sno NOT IN (SELECT sc.sno FROM sc INNER JOIN course ON sc.cno = course.cno WHERE (course.cname = &apos;数据库原理&apos;))从student表中查询学号姓名，条件是sno不等于（从【sc和course表中cno相同】中选出sno，条件是cname为数据库原理） 查询至少选修了【学号为“31401”的学生所选修的所有课程】的学生的学号和姓名； EXCEPT 仅返回那些不存在于第二个 SELECT 语句结果的记录（差集） DISTINCT 关键字同 SELECT 语句一起使用，可以去除所有重复记录，只返回唯一项 EXISTS 和 NOT EXISTS 表示是否存在，只返回True/False 123456select distinct sno, snamefrom student where not exists ((select cno from sc where sno=’31401’) except (select cno from sc where sc.sno=student.sno));（31401选的课程号减去别的同学所选的课程号）【判断是否存在】，不存在返回真，选出不重复的学生 但是MYSQL没有except关键字，只能用建立视图解决问题： 视图的优点：简单、安全、数据独立 左连接where只影向右表，右连接where只影响左表 「select * from tbl1 Left Join tbl2 where tbl1.ID = tbl2.ID」 左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据 12345678910111213create view temp as select distinct cno from sc where sno=’31401’;第一步，选出学号为31401所选的所有课程，创建视图create view ttemp as select temp.cno, sno from temp left join sc on temp.cno=sc.cno ; 第二步，选出cno和sno，从temp表以及sc表中cno相同的数据，「对照temp.cno把学号输入一遍」，创建视图另一种写法：【create view ttemp as select temp.cno, sno from temp, sc where temp.cno=sc.cno(+)】select sno,sname from student where sno in (select sno from ttemp group by sno having count(distinct cno)=3);第三步，查找从学生表中查询学号姓名，条件是sno等于【从ttemp中选出sno，不重复的cno个数大于等于3的sno】 由浅入深多表查询多表连接分为三类 内连接：（joind，inner join） 外连接：（left join，left outer join，right join，right outer join，union） 交叉连接：（cross join） 一、内连接语法： 对内连接 123SELECT table1.column, table2.columnFROM table1, table2WHERE table1.column1 = table2.column2; 例：查询每个员工的工号，姓名，工资，部门名和工作地点 123SELECT empno, ename, sal, dname, loc FROM emp, deptWHERE emp.deptno=dept.deptno; 内连接的另一种写法： 123SELECT empno,ename,job,sal,dept.deptno,dname,locFROM emp JOIN dept ON (emp.deptno=dept.deptno); 二、外链接语法 对外连接 123SELECT table1.column, table2.column --右外连接FROM table1, table2WHERE table1.column(+) = table2.column; 123SELECT table1.column, table2.column --左外连接FROM table1, table2WHERE table1.column = table2.column(+); 左外连接就是把左边的表内容全列出来，右边的只显示相同的部分，不存在的写NULL。右外连接就是把右边表内容全列出来，左边只显示相同的部分，不存在的写NULL。全连接就是完整返回左右表所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 例：查询每个员工的工号，姓名，工资，部门名和工作地点 123SELECT empno,ename,job,sal,dept.deptno,dname,loc --右外连接FROM emp,deptWHERE emp.deptno(+)=dept.deptno; 另一种写法： 12SELECT empno,ename,job,sal,dept.deptno,dname,loc --右外连接FROM emp right join dept on (emp.deptno=dept.deptno); 左外链接： 12SELECT empno,ename,job,sal,dept.deptno,dname,loc --左外连接FROM emp left join dept on (emp.deptno=dept.deptno); 全连接： 12SELECT empno,ename,job,sal,d.deptno,dname,locFROM emp e full join dept d on (e.deptno=d.deptno); 三、交叉连接（笛卡尔积） 实际应用中还有这样一种情形，想得到A，B记录的排列组合，即笛卡儿积，这个就不好用集合和元素来表示了。需要用到cross join 12SELECT empno,ename,dnameFROM emp cross join dept; 数据库ODBC接口 利用C语言编程实现简单的数据库应用程序，掌握基于ODBC的数据库访问的基本原理和方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include"windows.h"#include"sql.h"#include"sqlext.h"#include"sqltypes.h" #include"odbcinst.h"struct course_cell&#123; char cno[5]; char cname[20]; int lhour; int credit; char semester[5];&#125;;unsigned char sql_select[]="select * from db.course"; //SQL查询语句 unsigned char sql_dolist[3][100]=&#123;"insert into db.course values('C27','internet',48,2,'')", "update db.course set semester='τ' where cno='C27'", "delete from db.course where cno='C27'"&#125;; //插入、修改、删除语句 unsigned char do_name[3][10]=&#123;"insert","update","delete"&#125;;void show_course(HDBC hdbc) //显示course的内容&#123; HSTMT hstmt; RETCODE retcode; long lenOut1,lenOut2,lenOut3,lenOut4,lenOut5; struct course_cell* ccell; ccell = (struct course_cell*)malloc(sizeof(struct course_cell)); retcode=SQLAllocStmt(hdbc,&amp;hstmt); if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123;//SQLBindCol将应用程序的数据缓冲绑定到结果集的各列 retcode=SQLBindCol(hstmt,1,SQL_C_CHAR,ccell-&gt;cno,5,&amp;lenOut1); retcode=SQLBindCol(hstmt,2,SQL_C_CHAR,ccell-&gt;cname,20,&amp;lenOut2); retcode=SQLBindCol(hstmt,3,SQL_C_SLONG,&amp;ccell-&gt;lhour,sizeof(int),&amp;lenOut3); retcode=SQLBindCol(hstmt,4,SQL_C_SLONG,&amp;ccell-&gt;credit,sizeof(int),&amp;lenOut4); retcode=SQLBindCol(hstmt,5,SQL_C_CHAR,ccell-&gt;semester,5,&amp;lenOut5); retcode=SQLExecDirect(hstmt,sql_select,SQL_NTS); //把SQL语句送到数据库服务器，请求执行由SQL语句定义的数据库访问 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; printf("db.course is as following:\n"); printf("----------------------------------------------------------------\n"); printf("cno cname lhour credit semester\n"); retcode=SQLFetch(hstmt); /*SQLFetch fetches the next rowset of data from the result set and returns data for all bound columns.相当与SQLFetchAdvances和SQLGetData两个函数*/ while(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; printf("%-10s%-20s%-15d%-16d%-5s\n", ccell-&gt;cno,ccell-&gt;cname,ccell-&gt;lhour,ccell-&gt;credit,ccell-&gt;semester); retcode=SQLFetch(hstmt); &#125; printf("----------------------------------------------------------------\n\n"); &#125; &#125; SQLFreeStmt(hstmt,SQL_DROP);//释放语句句柄&#125; int main()&#123; HENV env; //定义环境句柄 HDBC hdbc; //定义链接句柄 HSTMT hstmt; //定义语句句柄 RETCODE retcode; retcode=SQLAllocEnv(&amp;env); //初始化ODBC环境，返回环境句柄 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; retcode=SQLAllocConnect(env,&amp;hdbc); //为连接句柄分配内存并返回链接句柄 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; retcode=SQLConnect(hdbc,(SQLCHAR*)"test",SQL_NTS,(SQLCHAR*)"root",SQL_NTS,(SQLCHAR*)"",SQL_NTS); //连接一个SQL数据资料 if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) &#123; show_course(hdbc); //显示初始的course内容 for(int i=0; i&lt;3; i++) //依次执行插入、修改、删除操作 &#123; retcode=SQLAllocStmt(hdbc,&amp;hstmt);//为语句句柄分配内存，并返回语句句柄 retcode=SQLExecDirect(hstmt,sql_dolist[i],SQL_NTS); //把SQL语句送到数据库服务器，请求执行由SQL语句定义的数据库访问 printf("%s ", do_name[i]); if(retcode==SQL_SUCCESS || retcode==SQL_SUCCESS_WITH_INFO) printf("success!\n\n"); else printf("fail!\n\n"); SQLFreeStmt(hstmt,SQL_DROP); //释放与语句句柄相关的资源 show_course(hdbc);//显示操作后的新course内容 &#125; SQLDisconnect(hdbc); //切断连接 &#125; SQLFreeConnect(hdbc); //释放与连接句柄相关的资源 &#125; SQLFreeEnv(env); //释放与环境句柄相关的资源&#125; return 0;&#125; 数据库完整性与安全性定义各基表的主键12345678910111213141516171819202122232425CREATE TABLE sc( sno varchar(6) NOT NULL, cno varchar(3) NOT NULL, grade int(11) DEFAULT NULL, PRIMARY KEY (sno,cno))DEFAULT CHARSET = gbk;Create Table student ( sno varchar(6) NOT NULL, sname varchar(6) DEFAULT NULL, sex varchar(2) DEFAULT NULL, bdate datetime DEFAULT NULL, dept varchar(8) DEFAULT NULL, classno varchar(3) DEFAULT NULL, PRIMARY KEY (sno)) DEFAULT CHARSET=gbk；Create Table course ( cno varchar(3) NOT NULL, cname varchar(12) DEFAULT NULL, lhour int(11) DEFAULT NULL, credit int(11) DEFAULT NULL, semester varchar(2) DEFAULT NULL, PRIMARY KEY (cno)) DEFAULT CHARSET=gbk； 删除和添加主键外键12345678alter table course drop primary key;alter table course add primary key(cno);alter table sc add constraint foreign key&lt;sno&gt; references student&lt;sno&gt;;alter table sc add constraint foreign key&lt;cno&gt; references course&lt;cno&gt;;show create table course;查看各表信息 验证完整型约束： 分别向学生表、课程表插入具有相同学号和相同课程编号的学生数据和课程数据，验证其实体完整型约束。可以看出对student和course插入具有相同学号和课程编号的学生数据，都失败了，验证其实体完整型约束。 向学生课表插入一条课表编号课程表中没有的，验证参照完整型约束。插入失败。 定义存储过程 存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。 存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。 首先定义存储过程的结束符 12DELIMITER //用delimiter修改结束符为// 声明存储过程 1create procedure demo_in_parameter(IN p_in int) 存储过程开始和结束符号: 1BEGIN .... END 变量赋值: 1SET @p_in=1 变量定义: 1DECLARE l_int int unsigned default 4000000; 创建mysql存储过程、存储函数: 1create procedure 存储过程名(参数) 存储过程体: 1create function 存储函数名(参数) 示例：创建数据库备份数据用于示例： 1234create database db1;use db1;create table PLAYERS as select * from TENNIS.PLAYERS;create table MATCHES as select * from TENNIS.MATCHES; 存储过程示例：「删除给定球员参加的所有比赛」 12345678delimiter // #将语句的结束符号从分毫；临时改为两个//# 使用 DELIMITER $$ 命令将语句的结束符号从分号 ; 临时改为两个 $$，使得过程体中使用的分号被直接传递到服务器，而不会被客户端（如mysql）解释。create procedure delete_matches(IN p_playerno INTEGER)BEGIN delete from MATCHES where playerno = p_playerno;END//delimiter; #将语句的结束符号恢复为分号 调用存储过程： 1call sp_name[(传参)]； 触发器 MySQL包含对触发器的支持。触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。 创建触发器语法： 123456CREATE TRIGGER trigger_name #nametrigger_time #触发时机，before/aftertrigger_event ON tbl_name #触发事件：insert/update/delete 建立触发器表名，在哪张表建立触发器。FOR EACH ROWtrigger_stmt #触发器程序体，可以是SQL语句也可以是BEGIN和END包含的多条语句（delimiter）# 由此可见，可以创建（2x3）六种触发器 示例： 假设系统中有两个表：班级表 class(班级号 classID, 班内学生数 stuCount)学生表 student(学号 stuID, 所属班级号 classID)要创建触发器来使班级表中的班内学生数随着学生的添加自动更新，代码如下： 12345678910DELIMITER $create trigger tri_stuInsertAFTER INSERTON student FOR EACH ROWBEGINdeclare c int; #变量定义set c = (select stuCount from class where classID=new.classID); #变量赋值update class set stuCount = c + 1 where classID = new.classID; #变量操作END$DELIMITER ; 数据库查询分析深入理解分组查询例题：把统计时间（statistic）相同的，服务域（service_domain_moid）a中的hd100的数量和hd100s的数量的和计算出来： 首先，我们把service_domain_moid为a的筛选出来，如下： 12SELECT hd100, hd100s FROM statisticWHERE service_domain_moid=&quot;a&quot;; 其次： 我们把统计时间（statistic_time）相同的分组，求和 123SELECT sum(hd100),sum(hd100s)FROM statistic WHERE service_domain_moid=&quot;a&quot;GROUP BY statistic_time; 最后，统计结果按降序排序： 1234SELECT sum(hd100),sum(hd100s)FROM statistic WHERE service_domain_moid=&quot;a&quot;GROUP BY statistic_timeORDER BY statistic_time desc; GROUP BY关键字可以将查询的结果按某个字段或多个字段进行分组，字段中值相等的为一组。其语法规则如下： 1GROUP BY 属性名 [HAVING 条件表达式] [WITH ROLLUP] ORDER BY关键字可以对记录进行排序，其语法规则如下： 1ORDER BY 属性名 [ASC|DESC] 数据库练习题：01 按部门名称查询出员工的人数大于等于100的语句.(员工:emp_employee, 部门名称: department,员工姓名chnalias.) 12SELECT department FROM emp_employeeGROUP BY department HAVING COUNT(*) &gt;= 100; 02 把员工的姓名、性别和年龄显示出来。（员工表emp_employee，员工姓名：chnalias，年龄age，性别：gender。性别表：pub_gendar_info，性别名称：smpalias,与员工表的性别无关） 12SELECT e.chnalias, e.smpalias, e.age FROM emp_employee e INNER JOIN pub_gender g ON(e.gender = g.smpalias) 04 删除员工表中的姓名重复的数据，只保留重复数据中的一条数据。（员工表emp_employee,员工姓名：chnalias） 1234DELETE FROM emp_employeeWHERE id NOT IN( SELECT MAX(id) AS id FROM emp_employee GROUP BY chnalias) AS关键字为查询的字段起一个别名，例如上面的语句里，给MAX(id)起个别名id【AS关键字可省略】 05 查询出差表中的每个员工最近的出差时间和员工姓名(出差表emp_travel,员工姓名chnalias,出差时间godate) 1SELECT chnalias, godate FROM emp_travel ORDER BY godate DESC 数据库查询练习01 没有选修课程编号为C1的学生姓名【多表查询】 首先找出C1对应的chosen_class表中的c_id 12SELECT chose_class.c_id FROM class, chosen_class WHERE class.c_id = chose_class.c_id AND c_name = &quot;C1&quot;; 然后找出没有选修C1的学生 12345SELECT s_name FROM student, chose_classWHERE student.s_id = chose_class.s_id AND c_id NOT IN ( SELECT chose_class.c_id FROM class,chose_class WHERE class.c_id = chose_class.c_id AND c_name = &quot;C1&quot;); 02 列出每门课程名称和平均成绩，并按照程序排序 先分组查找计算每门课对应的平均成绩： 12SELECT c_id, avg(grade) avggrade FROM chosen_classGROUP BY c_id 然后多表查询（名称+成绩）并按照程序排序： 12345SELECT c.c_name, avggrade FROM( SELECT c_id, avg(garde) avggrade FROM chosen_class GROUP BY c_id) b JOIN class c ON c.c_id = b.c_id ORDER BY b.avggrade DESC; 03 选了2门课以上的学生姓名 统计学生id对应的选课数 12SELECT s_id, count(*) countclass FROM chosen_classGROUP BY s_id 1234SELECT s.s_name, b.countclass FROM( SELECT s_id, count(*) countclass FROM chosen_class GROUP BY s_id) b JOIN student s ON (s.s_id = b.s_id)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[裂纹识别初探]]></title>
    <url>%2F2017%2F10%2F23%2FCrackIdentify%2F</url>
    <content type="text"><![CDATA[裂纹识别的基本步骤 基于概率模型的裂纹识别算法总结 思路：仍然基于传统的模式识别方法，通过计算已知模板与图像的相关性，但是裂纹的形状与走向具有很大的随机性，引入概率论可以更好地建立模板。将概率论引入到理想裂纹模型的建立中，并将所建立的概率模型映射为理想模板。通过计算理想模板与图像像素点对应区域的Bhattacharyya系数来评定像素为裂纹的可能性。进而从X光图像中自动地提取裂纹轮廓。 关于Bhattacharyya系数（相似系数）：可以衡量两个向量间的相似程度。 裂纹中心点概率模型：通过观察裂纹图像发现裂纹中心点灰度低，两侧稍高，裂纹整体灰度地域背景灰度。根据裂纹图像的特点，将裂纹的中心曲线看作是裂纹中心点沿着曲线运动的轨迹。假设理想裂纹的中心点分布概率服从高斯分布，则任意剖面都满足高斯分布。模型窗口中心点是裂纹中心点的概率最大。 理想裂纹模板：基于裂纹灰度分布特点，将理想模型映射成理想模板。 裂纹识别算法： 图像预处理：（处理背景噪声） 斯通滤波：图像中的噪声绝大部分都位于图像频谱中的高频部分，通过高斯低通滤波器，滤除原始图像中的高频部分，避免理想模板与噪声发生误匹配。 阈值分割：采用改进的OSTU方法对图像进行灰度阈值分割，计算出合适的灰度阈值T 灰度拉伸：根据灰度阈值T，将灰度值高于T的像素灰度置为255.确定合适的门限值M，讲地域该门限的像素灰度置为0，根据先验经验，裂纹中心灰度的范围浮动低于10个灰度级左右。（二值化） 灰度拉伸的作用：增强原始图像的对比度，增加裂纹与模板的相似程度，从而增加了识别的准确性 算法流程： 根据式(2)将理想概率模型映射为理想模板矩阵 B。 统计模板矩阵 B 中元素对应的灰度概率分布，建立模 板的概率矩阵 B1，B1 中的元素为 B 中该元素灰度值在模板 中出现的概率。 对预处理后的原始图像进行逐像素循环，计算以当前 点为中心，模板矩阵区域大小内像素灰度分布概率为 i p ，再 根据 i p 与 B1 计算该区域对应的 Bhattacharyya 系数，并将其 作为当前点的替代值，遍历原始图像后生成相似系数矩阵。 将相似系数矩阵映射为灰度图像矩阵，并将其二值化。 对二值图像进行形态学操作，从而在二值图像中得到 裂纹的完整轮廓。将裂纹的轮廓和所在区域在原始图像中标 记出来，从而达到识别裂纹的目的。 形态学操作——消除二值化后的的噪声点 形态学操作流程：图像取反—关运算—膨胀—填充—腐蚀 形态学操作中膨胀和腐蚀的尺度必须一致，否则得到的轮廓尺寸便被人为地引入了方法误差。 经过形态学操作后得到了完整的裂纹轮廓，通过边缘检测算法，将该二值图像中的裂纹轮廓重绘于其对应的原始图像上，并在原始图像上标定出裂纹区域信息，从而完成了对裂纹的识别。 基于图像处理的微波处理材裂纹总结 思路：利用matlab软件中的图像处理模块，通过编程对微波处理木材表面裂纹的彩色扫描图像类型转换、图像增强、图像分割及图像形态学处理，提取图像中存在的裂纹，并最终对裂纹信息进行统计。 图像类型转换： Matlab图像处理模块提供了许多图像类型转换函数，通过这些函数可以实现RGB图像、灰度图像、索引图像及二值图像之间的相互变换。 由于图像后期处理都是在灰度图像基础上进行的，所以需要先将彩色扫描图像转换为灰度图像。在Matlab软件中，可通过调用rgb2gray函数实现彩色图像至灰度图像的转换。 图像增强： 在获取图像的过程中，各种干扰因素的存在会导致源图像中存在噪声，从而影响图像的质量。因此必须先对图像进行增强处理，图像增强可以将图像中感兴趣的特征有选择地突出，并衰减不需要的特征，以便后期对图像特征进行识别分析。 增强对比度：使源图像中各部分的反差增强。本文进行对比度增强处理的目的是使源图像中裂纹区域与其他部分的区别更为明显，主要通过imadjust函数实现。 锐化处理：经过以上的平滑滤波器对图像进行处理后，图像会有一定程度的模糊，进行锐化处理以突出图像的边缘信息，加强图像的轮廓特征，以便于人眼观察和机器识别。 二值图降噪处理：通过调用bwareaopen函数去除尺寸较小的噪声，经过降噪处理后，图像中有部分尺寸较大的噪声仍未去除，如果加大去噪过程中去除对象的尺度，会同时将部分较小的裂纹去除，因此不能采用该方法。而通过roifill函数，采用区域填充的方法可以达到去除大尺寸噪声的目的。 断裂纹闭合：采用形态学处理中的闭运算操作，通过创建一个平面的线性结构元素使裂纹的断裂区域闭合。 裂纹信息统计：采用matlab软件中形态学处理的操作，获得裂纹数量、裂纹长度、宽度及面积等信息，并由此计算机出图像中裂纹区域所占图像面积的比例。首先调用bwlabel函数对裂纹进行编号，可以统计图像中的裂纹数量。其次，利用regionprops函数可以计算出每条裂纹对应的长度、宽度和面积。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南京一日游XD]]></title>
    <url>%2F2017%2F09%2F16%2FNanJing%2F</url>
    <content type="text"><![CDATA[(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"video":{"url":"https://ts1989ed.oss-cn-shenzhen.aliyuncs.com/IMG_7305.mov"},"danmaku":{"id":"NanJing","api":"https://api.prprpr.me/dplayer3/"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>Vlog</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令对应的单词]]></title>
    <url>%2F2017%2F01%2F21%2FLinuxAbbreviation%2F</url>
    <content type="text"><![CDATA[特殊命名MySQL = My是最初作者女儿的名字，SQL = Structured Query LanguagePython 得名于电视剧Monty Python&rsquo;s Flying Circusawk = “Aho Weiberger and Kernighan” 三个作者的姓的第一个字母biff = 作者Heidi Stettner在U.C.Berkely养的一条狗,喜欢对邮递员汪汪叫。 目录名：/etc：ETCetera/bin：BINaries/dev：DEVices/lib：LIBraries/mnt：MouNT/proc：PROCesses/tmp：TeMPorary/var：VARiable/srv：SeRVices/opt：OPTion/sbin：Super BINaries（又作Superuser BINaries）/sys：SYStem/usr：Unix Shared Resources 文件管理（包括文件输出管理）：ls – LiStcd – Change Directorypwd – Print Working Directorycp – CoPymv – MoVerm – ReMovepushd – PUSH to Directorypopd – POP from Directorymkdir – MaKe DIRectoryrmdir – ReMove DIRectorycat – CATenatesed – Stream EDitordiff – DIFFerencewc – Word Countchmod – CHange MODechown – CHange OWNerchgrp – CHange GRouPawk – Aho Weinberger and Kernighangawk – Gnu Aho Weinberger and Kernighangrep – General Regular Expression Println – LiNktar – TARball 硬件管理：df – Disk Freedu – Disk Usagedd – Data Descriptionparted – PARTition EDitorlspci – LiSt Peripheral Component Interconnectlscpu – LiSt Central Process Unitlsusb – LiSt Universal Serial Bus 软件及软件包管理：man – MANualapt – Advanced Packaging Tooldpkg – Debian PacKaGeyum – Yellow dog Updater, Modifiedrpm – RPM Package Manager 系统管理：depmod – DEPend MODulelsmod – LiSt MODulemodprobe – MODule PROBEmodinfo – MODule INFOrmationinsmod – INSert MODulermmod – ReMove MODuleps – Processes Statussu – Substitute Userbash – Bourne Again SHellinit – INITializationssh – Secure SHellwine – Wine Is Not an Emulatorexec – EXECutefstab – FileSystem TABlepasswd – PASSWorDtty – TeleTYpesudo – SuperUser DOgrub – GRand Unified Bootloadertzselect – Time Zone SELECTsync – SYNChronize 编辑器：ed – EDitornano – Nano’s ANOther editoremacs – Editor MACroSvi – VIsualvim – Vi Improved 写程序时会用到的：cc – C Compilergcc – Gnu Compiler Collectiongcc – Gnu C Compilerg++ – Gnu c++ compilergcj – Gnu Compiler for Javayacc – Yet Another Compiler Compilerguile – Gnu Ubiquitous Intelligent Language for Extensionsgas – Gnu Assemblerphp – PHP：Hypertext Preprocessorld – Link eDitorgdb – Gnu DeBugtcl – Tool Command Line 图形界面：gnome – GNu Object Model Environmentgdm – Gnome Display Managergtk – Graphic user interface ToolKitqt – Toolkitkde – K Desktop Environmentlxde – Lightweight X11 Desktop Environmentxfce – XForms Common Environment 各种参数-a | –all ; –archive ; –append-b | –blocksize ; –batch-c | –commands ; –create-d | –debuge ; –delete ; –directory-e | –execute ; –edit ; –exclude-f | –force ; –file ; –configuration file-h | –help ; –human readable ; –headers-i | –interactive ; –include-k | –keep ; –kill-l | –long listing format ; –list ; –load-m | –message ; –manual ; –create home-n | –number ; –no-o | –output ; –options-p | –port ; –protocol ; –passwd-q | –quiet-r | –reverse ; –recursive-s | –silent ; –size ; –subject-t | –tag ; –type-u | –user-v | –verbose ; –version-w | –width ; –warning-x | –exclude-y | –yes-z | –zip 许可证：gnu gpl : Gnu General Public Licensegnu lgpl : Gnu General Lesser Public Licensegfdl : Gnu Free Documentation Licenseagpl : Affero General Public Licenseapsl : Apple Public Source Licensebsd : Berkeley Software Distribution license]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《鸟哥的私房菜》思维导图]]></title>
    <url>%2F2017%2F01%2F17%2FLinuxXmind%2F</url>
    <content type="text"><![CDATA[Linux学习计划 Linux文件、目录与磁盘格式 Shell与Shell Script]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb总结]]></title>
    <url>%2F2017%2F01%2F02%2FJavaWeb-bili%2F</url>
    <content type="text"><![CDATA[01 JSP环境搭建JSP动态网页 静态、动态：是否随着 时间、地点、用户操作 的改变而改变 动态网页：需要使用到服务器脚本语言（JSP） 架构C/S、B/S架构 C/S架构的不足：（QQ） 如果软件升级、所有软件都需要升级 维护麻烦，需要维护每一台客户端软件 每一个客户都需要安装客户端软件 B/S架构：（京东网页） 客户端可以通过浏览器直接访问服务端 Tomcat解压后的目录bin：可执行文件（startup.bat、shutdown.bat） conf：配置文件（server.xml） lib：Tomcat依赖的jar文件 log：日志文件（记录出错信息） temp：临时文件 webapps：可执行的项目（将我们开发的项目放入该目录） work：存放由jsp翻译成的Java，以及编辑成class文件（tsp -&gt; java -&gt; class） 配置Tomcat 配置jdk（必须配置Java_HOME）java_home、classPath、path 配置catalina_home 双击 bin/startup.bat 启动tomcat 常见错误：可能与其他服务器端口号冲突。（默认端口8080） 修改端口号：conf/server.xml（70行左右） 访问Tomcathttp://localhost:8888/ 常见状态码： 200: 一切正常 300/301: 页面重定向 404: 资源不存在 403:权限不足（如果访问a目录，但是a目录设置 不可见） 500: 服务器内部错误（代码有误） Apache项目文件结构 如果有index.jsp和index2.jsp文件，通过 welcome 设置默认的初始页面。 JSP：在HTML中嵌套的Java代码 虚拟路径将web项目配置到webapps以外的目录——【配置虚拟路径】 server.xml 文件 Host 代码块内写一个 Context 代码： docBase：实际路径 path：虚拟路径（绝对路径、相对路径「相对于webapps」） 方法二： 在 conf/Catalina/localhost 新建文件 「项目名」.xml 中新增一行 虚拟主机通过 www.test.com 访问本机配置 server.xml 中的 Host 代码块 12345添加Host代码块&lt;Host appBase="D:\study\JspProject" name="www.test.com" &gt; &lt;Context docBase="D:\study\JspProject" path="/"&gt;&lt;/Context&gt;&lt;/Host&gt;并修改默认引擎中的 defaultHost=“www.test.com" 配置电脑的 hosts 文件，添加映射 127.0.0.1 到 www.test.com 访问： www.test.com:8888 网站默认端口是 80 ，只要端口改成 80 ，就可以省略端口号 流程：www.test.com -&gt; host找映射关系 -&gt; server.xml 找 Engine 的 defaultHost -&gt; 通过 “/” 映射到 D:\study\JspProject 为了后续学习，将以上恢复改端口、改Engine、删Hosts JSP执行流程第一次访问服务端将jsp翻译成java（Servlet文件），再将Java编译成class文件 最终存放在 D:\study\apache-tomcat-8.5.30\work\Catalina\localhost\JspProject\org\apache\jsp 第二次访问直接访问class（如果服务端修改了代码，将会在访问中重新翻译和编译） Jsp和Servlet可以相互转换]]></content>
      <categories>
        <category>Todo</category>
      </categories>
      <tags>
        <tag>IT</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
</search>
